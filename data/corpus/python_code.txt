# MacOS installer
# Usage: make all

from setuptools import setup

APP = ["../src/editor.py"]

APP_NAME = "Stone Story RPG Save editor"
APP_VERSION = "1.2.0"

DATA_FILES = [
    "../src/translations",
    "../src/fonts",
    "../src/images",
    "../src/settings.toml",
    ("save", [
        "../src/save/save_file.py",
        "../src/save/get_file.py"
    ]),
]

OPTIONS = {
    'iconfile': '../src/images/icon.icns',
    "packages": [
        "dearpygui",
        "natsort",
        "pprp",
        "pyperclip"
    ],
    "includes": [
        "tkinter.filedialog",
        "os.remove",
        "os.path",
        "os.name",
        "sys.argv",
        "getpass.getuser"
    ],
    "plist": {
        "CFBundleName": APP_NAME,
        "CFBundleDisplayName": APP_NAME,
        "CFBundleGetInfoString": "Save editor for Stone Story RPG game",
        "CFBundleIdentifier": "com.catalyst.ssrpgs",
        "CFBundleVersion": APP_VERSION,
        "CFBundleShortVersionString": APP_VERSION,
        "NSHumanReadableCopyright": u"Copyright © 2025, Catalyst",
        "LSUIElement": True
    }
}

setup(
    app=APP,
    data_files=DATA_FILES,
    options={
        "py2app": OPTIONS
    },
    setup_requires=["py2app"]
)
import dearpygui.dearpygui as dpg

from subprocess import check_output
from tkinter import filedialog
from sys import executable
from os import path, remove

from save.save import Save

from tabs.main_tab import MainTab
from tabs.locations_tab import LocationsTab
from tabs.inventory_tab import InventoryTab
from tabs.cosmetics_tab import CosmeticsTab
from tabs.progress_tab import ProgressTab
from tabs.quests_tab import QuestsTab
from tabs.times_tab import TimesTab

from tools.setup import *
from tools.utils import loading, add_help

class Editor:
    def __init__(self):
        self.save = Save()
        self.save.encrypt_saves = settings["encrypt_saves"]

        self.main_tab = MainTab(self.save)
        self.progress_tab = ProgressTab(self.save)
        self.locations_tab = LocationsTab(self.save)
        self.inventory_tab = InventoryTab(self.save)
        self.cosmetics_tab = CosmeticsTab(self.save)
        self.quests_tab = QuestsTab(self.save)
        self.times_tab = TimesTab(self.save)

    def load(self):
        if IS_NT:
            filetypes = [
                ("Save file (.txt)", "*.txt"),
                ("Json file (.json)", "*.json")
            ]

            initialdir = path.join(
                path.expandvars('%USERPROFILE%'),
                'AppData/LocalLow/Martian Rex, Inc_/Stone Story/'
            )
 
            save_file = filedialog.askopenfilename(
                filetypes=filetypes,
                initialdir=initialdir
            )
        else:
            save_file = check_output([
                executable,
                "save/get_file.py"
            ])  # I don't know what's wrong with dpg
            save_file = str(save_file, encoding="utf-8")

        print(f"Gathered save file {save_file}")

        if save_file.endswith(".txt"):
            print("Loading as .txt")
            with loading():
                self.save.open(save_file)

        elif save_file.endswith(".json"):
            print("Loading as .json")
            self.save.open_from_json(save_file)

        else:
            print(f"Loading denied")
            return

        # Update tabs
        dpg.configure_item(
            "save_slots",
            items=self.save.save_slots,
            default_value=self.save.save_slot
        )

        self.change_slot("load", self.save.save_slot)

    def dump(self):
        if not self.save.is_loaded():
            return

        if IS_NT:
            # Get path and filename
            trace = self.save.save_file_name.split('/')

            defaultextension = trace[-1].split('.')[-1]
            initialdir = '/'.join(trace[:-1])
            initialfile = trace[-1]
            filetypes = [
                ("Save file (.txt)", "*.txt"),
                ("Json file (.json)", "*.json")
            ]

            if defaultextension == "json":
                filetypes.reverse()

            file = filedialog.asksaveasfile(
                confirmoverwrite=False,
                defaultextension=defaultextension,
                filetypes=filetypes,
                initialdir=initialdir,
                initialfile=initialfile
            )

            if file is not None:
                # Delete touched file
                file.close()
                remove(file.name)

                save_file = file.name
            else:
                save_file = ""

        else:
            save_file = check_output([
                executable,
                "save/save_file.py",
                self.save.save_file_name
            ])  # I don't know what's wrong with dpg
            save_file = str(save_file, encoding="utf-8")

        print(f"Gathered save file {save_file}")

        if save_file.endswith(".txt"):
            with loading():
                self.save.save(save_file)
                print("Saved as .txt")
        elif save_file.endswith(".json"):
            self.save.save_as_json(save_file)
            print("Saved as .json")

    def change_slot(self, _, new_save_slot):
        self.save.save_slot = new_save_slot

        # Sync values in fields
        self.main_tab.load()
        self.progress_tab.load()
        self.locations_tab.load()
        self.inventory_tab.load()
        self.cosmetics_tab.load()
        self.quests_tab.load()
        self.times_tab.load()

    def configure_language(self, _, language):
        for code in languages:
            if languages[code] != language:
                continue

            settings["language"] = code

            self.update_settings()
            print(f"Default language is set to {code}")

    def configure_upscale(self, _, upscale):
        settings["upscale"] = upscale

        self.update_settings()
        print(f"Upscale is set to {upscale}")

    def configure_save_encryption(self,_, encrypt_saves):
        self.save.encrypt_saves = encrypt_saves
        settings["encrypt_saves"] = encrypt_saves

        self.update_settings()
        print(f"Encryptions is set to {encrypt_saves}")

    def update_settings(self):
        with open("settings.toml", "w", encoding="utf-8") as config:
            config.write(f"# Save editor\n")
            config.write(f"language = \"{settings["language"]}\"\n")
            config.write(f"upscale = {str(settings["upscale"]).lower()}\n")
            config.write(f"\n# Files\n")
            config.write(f"encrypt_saves = {str(settings["encrypt_saves"]).lower()}\n")

    def gui(self):
        with dpg.window(tag="Editor"):
            # Header
            with dpg.menu_bar():
                dpg.add_button(
                    label=i18n["open"],
                    callback=self.load
                )
                dpg.add_button(
                    label=i18n["save"],
                    callback=self.dump
                )
                dpg.add_combo(
                    label=i18n["save_slot"],
                    width=135 * SCALE,
                    items=[],
                    callback=self.change_slot,
                    tag="save_slots"
                )

            # Tabs
            with dpg.tab_bar():
                with dpg.tab(label=i18n["major_tab"]):
                    with dpg.child_window(
                        no_scrollbar=True,
                        border=False
                    ):
                        dpg.add_text(i18n["info_label"])
                        dpg.add_text(i18n["info"])

                        # Settings
                        dpg.add_separator()
                        with dpg.table(header_row=False, resizable=True):
                            dpg.add_table_column()
                            dpg.add_table_column()

                            with dpg.table_row():
                                # Editor settings
                                with dpg.group():
                                    dpg.add_text(i18n["settings"])
                                    dpg.add_combo(
                                        label=i18n["language"],
                                        default_value=i18n["language-name"],
                                        items=list(languages.values()),
                                        callback=self.configure_language
                                    )
                                    add_help(i18n["language_info"])

                                    if IS_NT:
                                        dpg.add_checkbox(
                                            label=i18n["double_resolution"],
                                            default_value=settings["upscale"],
                                            callback=self.configure_upscale
                                        )

                                # File settings
                                with dpg.group():
                                    dpg.add_text(i18n["files"])
                                    dpg.add_checkbox(
                                        label=i18n["encrypt_saves"],
                                        default_value=settings["encrypt_saves"],
                                        callback=self.configure_save_encryption
                                    )

                with dpg.tab(label=i18n["main_tab"]):
                    self.main_tab.gui()

                with dpg.tab(label=i18n["progress_tab"]):
                    self.progress_tab.gui()

                with dpg.tab(label=i18n["locations_tab"]):
                    self.locations_tab.gui()

                with dpg.tab(label=i18n["inventory_tab"]):
                    self.inventory_tab.gui()

                with dpg.tab(label=i18n["cosmetics_tab"]):
                    self.cosmetics_tab.gui()

                with dpg.tab(label=i18n["quests_tab"]):
                    self.quests_tab.gui()

                with dpg.tab(label=i18n["times_tab"]):
                    self.times_tab.gui()

    def run(self):
        dpg.create_context()

        init_font()
        init_theme()

        self.gui()

        dpg.create_viewport(
            title=str(i18n["title"]),
            width=WIDTH * SCALE + WIDTH_OFFSET,
            height=HEIGHT * SCALE + HEIGHT_OFFSET,
            small_icon="images/icon.ico",
            x_pos=450 * SCALE,
            y_pos=350 * SCALE
        )

        dpg.setup_dearpygui()
        dpg.show_viewport()
        dpg.set_primary_window("Editor", True)
        dpg.start_dearpygui()
        dpg.destroy_context()

editor = Editor()
editor.run()
from pytesseract import image_to_string
from PIL import Image

def image_to_text(image):
    return image_to_string(image).split()

def main():
    import sys
    import pathlib

    img_path = pathlib.Path(sys.argv[1])
    if not img_path.is_file():
        sys.exit("Invalid image path")

    img_path = str(img_path.resolve())
    results = image_to_text(Image.open(img_path))
    print(results)

if __name__ == "__main__":
    main()
from os import system
from time import sleep

from pynput.mouse import Button
from pynput.mouse import Controller as MouseController

from pynput.keyboard import Controller as KeyboardController

from pyautogui import screenshot as pyScreenshot
from pyautogui import ImageNotFoundException
from pyautogui import locateCenterOnScreen
from pyautogui import locate as pyLocate
from pyautogui import center as pyCenter
from pyautogui import pixel as pyPixel

from tesseract import image_to_text
from numpy import array

mouse = None
keyboard = None

# System operations
def wait(seconds):
    sleep(seconds)

def launch(programm):
    system(f"open '{programm}'")

# Mouse operations
def init_mouse():
    global mouse
    mouse = MouseController()

def click(pos, button=Button.left, t1=0.1, t2=0.2):
    mouse.position = pos
    sleep(t1)
    mouse.click(button)
    sleep(t2)

def hold(pos, button=Button.left, t1=0.2, t2=1, t3=0.1):
    mouse.position = pos
    sleep(t1)
    mouse.press(button)
    sleep(t2)
    mouse.release(button)
    sleep(t3)

def scroll(dx, dy, t1=0.1):
    mouse.scroll(dx, dy)
    sleep(t1)

# Keyboard operations
def init_keyboard():
    global keyboard
    keyboard = KeyboardController()

def sendstring(string, t1=0.1):
    keyboard.type(string)
    sleep(t1)

# Screenshot operations
def screenshot(region=None, filename=None):
    screenshot = pyScreenshot(region=region)

    if filename is not None:
        screenshot.save(f"samples/{filename}")

    return screenshot

def pixel(xy):
    return pyPixel(*xy)

def recognize(sample):
    return image_to_text(sample)

def wait_loot(where):
    mouse.position = where
    sleep(1)

    while True:
        try:
            locateCenterOnScreen("samples/chest_opening_part.png")
            for _ in range(5):
                mouse.click(Button.left)
                sleep(0.1)

        except ImageNotFoundException:
            break

def wait_for(sample, region=None):
    while True:
        try:
            locateCenterOnScreen(f"samples/{sample}", region=region)
            break
        except ImageNotFoundException:
            sleep(0.5)

def wait_until(sample):
    while True:
        try:
            locateCenterOnScreen(f"samples/{sample}")
            sleep(0.5)
        except ImageNotFoundException:
            break

def locate(sample, screen, confidence=0.999, region=None):
    try:
        return pyCenter(pyLocate(
            f"samples/{sample}",
            array(screen),
            confidence=confidence,
            region=region
        ))
    except ImageNotFoundException:
        return False

# Points and regions operations
def scale(region, factor):
    if factor == 1:
        return region
    
    scaled_region = [coordinate * factor for coordinate in region]
    
    if not isinstance(factor, int):
        scaled_region = [int(coordinate) for coordinate in region]

    return scaled_region
import argparse
from time import time

from settings import *
from controller import *

init_mouse()
init_keyboard()

# Main
wait(3)

line = 0
farm_start = time()

try:
    while True:
        for cell in range(1, 6):
            click(points["items"][f"bottom_cell_{cell}"], t2=0.1)

        line += 1

except KeyboardInterrupt:
    farm_time = time() - farm_start

    print(f"\rDone after {round(farm_time / 60, 1)}m and {line} lines")
    exit()
import argparse
from time import time

from settings import *
from controller import *

init_mouse()
init_keyboard()

def parseargs():
    parser = argparse.ArgumentParser(add_help=False)

    def timestring(value):
        if value[-1] not in {"s", "f"} or not value[:-1].isdigit():
            raise argparse.ArgumentTypeError(
                "Specify seconds or tics of run time (10s or 300f etc.)"
            )

        return int(value[:-1]) // {'s': 1, 'f': 30}[value[-1]]

    # Add arguments
    parser.add_argument(
        "-h", "--help",
        action="help",
        default=argparse.SUPPRESS,
        help="Show all parameters and exit"
    )
    parser.add_argument(
        "time",
        help="Time of one run",
        type=timestring
    )
    parser.add_argument(
        "-l", "-lim", "-limit",
        help="Limit number of runs",
        type=int
    )
    parser.add_argument(
        "-p", "-pos", "-position",
        default="bottom",
        choices=("top", "center", "bottom"),
        help="Choose location's icon position"
    )

    return parser.parse_args()

# Main
wait(3)
args = parseargs()

wait_loops = args.l
wait_time = args.time
location_position = args.p

loop = 0
farm_start = time()

try:
    while True:
        # Choose location
        click(points["locations"][f"unsafe_{location_position}"], t2=0.5)
        click(points["locations"]["farm_explore_button"])

        # Farm
        wait(wait_time)

        # Exit from location
        sendstring(" ", 0.5)
        sendstring("l", 2)

        loop += 1

except KeyboardInterrupt:
    farm_time = time() - farm_start

    print(f"\rDone after {round(farm_time / 60, 1)}m and {loop} loops")
    exit()
import json
from datetime import datetime

from matplotlib import ticker
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

import numpy as np

# Load sessions data
sessions = json.load(open("save.json", "rb"))

# Define styles
style = {
    "chests": {
        "common": {"color": "tab:red", "label": "o Обычные"},
        "big": {"color": "tab:gray", "label": "8 Большие"},
        "omega": {"color": "tab:blue", "label": "Ω Омеги"},
        "delta": {"color": "tab:orange", "label": "∆ Дельты"},
        "emerald_egg": {"color": "tab:green", "label": "^ Изумрудные яйца"},
        "pinata": {"color": "tab:purple", "label": "ö Пиньяты"},
    },
    "resources": {
        "stone": {"color": "tab:green", "label": "o Камни"},
        "wood": {"color": "tab:brown", "label": "/ Дерево"},
        "tar": {"color": "tab:blue", "label": "~ Смола"},
        "bronze": {"color": "tab:red", "label": ": Бронза"},
        "ki": {"color": "tab:orange", "label": "@ Ки"},
        "crystals": {"color": "tab:purple", "label": "♦ Кристаллы"},
        "totalgp": {"color": "tab:gray", "label": "* Очки снаряжения"},
    }
}

# Initialize chests and resources
chests = {chest: 0 for chest in style["chests"]}
chests_history = {chest: [] for chest in chests}

resources = [resource for resource in style["resources"]]
resources_history = {resource: [] for resource in resources}

# Calculate data from sessions
for i, session in enumerate(sessions):
    for chest in chests:
        if chest in session["chests"] and session["chests"][chest] != "?":
            chests[chest] += session["chests"][chest]
        chests_history[chest].append(chests[chest])
    
    for resource in resources:
        if session["resources"][resource] == "?":
            resources_history[resource].append(0)
        elif resource in session["resources"]:
            resources_history[resource].append(session["resources"][resource])

# Init plots layout
fig, axs = plt.subplot_mosaic(
    [["chests", "resources"], ["launches", "launches"]],
    figsize=(12.5, 7.5),
)

fig.canvas.manager.set_window_title("Статистика SSRPGA")
ax = list(axs.items())

# Chests
for chest in chests:
    ax[0][1].plot(
        range(len(chests_history[chest])),
        chests_history[chest],
        linewidth=3,
        color=style["chests"][chest]["color"],
        label=style["chests"][chest]["label"]
    )

# Show chests stats
print("Сундуки:")
for chest in chests:
    print(f"{style["chests"][chest]['label']}: {chests[chest]:,}")
print()

ax[0][1].set_title("Сундуки")
ax[0][1].legend()
ax[0][1].set_xlim(0, len(chests_history["big"]))
ax[0][1].xaxis.set_major_locator(ticker.MultipleLocator(len(sessions) / 10))
ax[0][1].ticklabel_format(axis='y', style='sci', scilimits=(6, 6))
ax[0][1].set_ylim(0)
# ax[0][1].set_yscale("log")

# Resources
for resource in resources:
    ax[1][1].plot(
        range(len(resources_history[resource])),
        resources_history[resource],
        linewidth=3,
        color=style["resources"][resource]["color"],
        label=style["resources"][resource]["label"]
    )

# Print resources history
print("Ресурсы")
for resource in resources:
    print((
        f"{style["resources"][resource]['label']}: "
        f"{resources_history[resource][-1]:,}")
    )
print()

ax[1][1].set_title("Ресурсы")
ax[1][1].legend()
ax[1][1].set_xlim(0, len(resources_history["ki"]))
ax[1][1].xaxis.set_major_locator(ticker.MultipleLocator(len(sessions) / 10))
ax[1][1].set_ylim(0)
# ax[1][1].set_yscale("log")

# Calculate exit times from sessions
utc = 3 * 3600

dates = np.array([
    datetime.fromtimestamp(session ["info"]["exit_time"])
    for session in sessions
])

hours = np.array([
    datetime.fromtimestamp(date.hour * 3600 + date.minute * 60 + date.second - utc)
    for date in dates
])

colors = np.array([
    "tab:orange" if sum(session["chests"].values()) >= 400 else "tab:blue"
    for session in sessions
])

# Plot launches
for group in ["tab:orange", "tab:blue"]:
    ix = np.where(colors == group)
    ax[2][1].scatter(
        dates[ix],
        hours[ix],
        c=group,
        edgecolor="black",
        linewidth=1
    )

# Print sessions stats
total_runs_time = sum([
    session["info"]["run_time"] for session in sessions
    if session["info"]["run_time"] != "?"
])

print("Сессии")
print("Всего:", len(sessions))
print(f"Общее время: {round(total_runs_time / 3600)}ч")
print(f"Всего сундуков: {sum(chests[chest] for chest in chests):,}")
print(f"Среднее время: {
    round(total_runs_time / len([
        1 for session in sessions
        if session["info"]["run_time"] != "?"]
    ))}с"
)
print(f"Сундуков в среднем: {
    round(sum(chests[chest] for chest in chests) / len(sessions))
}")

ax[2][1].set_title("Запуски")
ax[2][1].legend(["Полные", "Неполные"])
ax[2][1].set_xlim(dates[0], dates[-1])
ax[2][1].xaxis.set_major_formatter(mdates.DateFormatter('%d.%m.%Y'))

ax[2][1].set_ylim(
    datetime.fromtimestamp(-utc),
    datetime.fromtimestamp(24 * 3600 - utc)
)
ax[2][1].yaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
ax[2][1].yaxis.set_major_locator(ticker.MultipleLocator(1 / 12))

plt.tight_layout()
plt.show()
import curses

from os import path
from re import sub, findall
from sys import argv, executable
from time import time
from json import dump, load
from datetime import datetime, timedelta
from subprocess import check_output

from Quartz import CGSessionCopyCurrentDictionary  # MacOS only

from settings import playthroughs
from settings import is_event_mode

s = 1
m = 60*s
h = 60*m
d = 24*h

# Load save
if path.exists("save.json"):
    sessions = load(open("save.json", "rb"))
else:
    sessions = []

def sign(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0

def save():
    dump(
        sessions,
        open("save.json", "w"),
        indent=4
    )

def parse(value):
    offset = 0
    if value.startswith(".") and sessions:
        offset = time() - sessions[-1]["info"]["exit_time"]

    value = sub(r"([-+]?\d+)(\s|$)", r"\1s ", value)  # Translate values without type to seconds (1 -> 1s)
    value = sub(r"(^|\s)(([-+]?)([smhd]))", r" \g<3>1\4 ", value)  # Add values to lone types (h -> 1h)
    value = [(r[0], r[-1]) for r in findall(r"([-+]?\d+(\.\d*)?)([smhd])", value)]  # Make (value, type) pairs

    for pair in value:
        offset += float(pair[0]) * {'s': s, 'm': m, 'h': h, 'd': d}[pair[1]]

    return offset

def main(screen):
    state = "wait"

    action = ""
    action_suggestions = (
        "stats",
        "chests",
        "lock",
        "offset",
        "resources",
        "ssrpga",
        "timeout",
    )

    wait_map = {
        key: parse(playthroughs[key]) * (0.5 if is_event_mode else 1) 
        for key in playthroughs
    }

    unlocked = True if "-l" not in argv else False
    offset = 0

    timeout = 1000
    screen.timeout(timeout)

    curses.use_default_colors()
    curses.init_pair(0, curses.COLOR_BLACK, -1)
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_BLUE, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)
    curses.init_pair(6, curses.COLOR_CYAN, -1)
    curses.init_pair(7, curses.COLOR_WHITE, -1)
    curses.curs_set(0)

    colors = {
        "black": curses.color_pair(0),
        "red": curses.color_pair(1),
        "green": curses.color_pair(2),
        "yellow": curses.color_pair(3),
        "blue": curses.color_pair(4),
        "magenta": curses.color_pair(5),
        "cyan": curses.color_pair(6),
        "white": curses.color_pair(7),
    }

    chests_icons = {
        "pinata": "ö",
        "emerald_egg": "^",
        "delta": "∆",
        "omega": "Ω",
        "big": "8",
        "common": "o",
    }

    resources_icons = {
        "stone": "o",
        "wood": "/",
        "tar": "~",
        "bronze": ":",
        "ki": "@",
        "crystals": "♦",
        "totalgp": "*",
    }
    
    while True:
        # Update time values
        if sessions:
            launch_time = sessions[-1]["info"]["exit_time"] + wait_map[sessions[-1]["info"]["exit_location"]] + offset
            launch_time_left = launch_time - time()
            launch_percent = (time() - sessions[-1]["info"]["exit_time"]) / (wait_map[sessions[-1]["info"]["exit_location"]] + offset)

            screen_unlocked = "CGSSessionScreenIsLocked" not in CGSessionCopyCurrentDictionary()
            if launch_time_left <= 0 and unlocked and screen_unlocked:
                state = "ssrpga"
        else:
            state = "ssrpga"

        # Draw current tab
        screen.clear()
        match state:
            case "wait":
                if launch_time_left > 0:
                    screen.addstr(f"[{len(sessions):0>4}]", colors["green" if unlocked else "blue"])
                    screen.addstr(f"{'- +'[sign(offset) + 1]}", curses.A_DIM)
                    screen.addstr(f"{str(timedelta(seconds=round(launch_time_left))):0>8} ")
                    screen.addstr(f"{launch_percent:0>7.3%} ")
                    screen.addstr(f"{datetime.fromtimestamp(launch_time).strftime("%H:%M:%S")}")

                    last_runs = sessions[-4:][::-1]
                    for i, last_run in enumerate(last_runs):
                        total_chests = sum([chest for chest in last_run["chests"].values() if chest != "?"])
                        eggs = last_run["chests"]["emerald_egg"]
                        deltas = last_run["chests"]["delta"]
                        pinatas = last_run["chests"]["pinata"]
                        session_id = len(sessions) - i
                        session_run_time = datetime.fromtimestamp(last_run["info"]["exit_time"]).strftime("%H:%M:%S")
                        
                        screen.addstr(
                            f" {session_id}  {session_run_time} {total_chests:>3} ∆{deltas} ^{eggs} ö{pinatas}",
                            curses.A_DIM
                        )

                        if i != 3:
                            screen.addstr("\n")
                else:
                    screen.addstr(f"[{len(sessions):0>4}] ", colors["yellow"])
                    screen.addstr(f"{str(timedelta(seconds=round(-launch_time_left))):0>8} ", colors["yellow"])
                    screen.addstr(f"{launch_percent:0>7.2%} ", colors["yellow"])
                    screen.addstr(f"{datetime.fromtimestamp(launch_time).strftime("%H:%M:%S")}", colors["yellow"])

            case "not available":
                screen.addstr("should be more than two sessions", colors["yellow"])

            case "chests":
                chests_gathered = sum(sessions[-1]["chests"].values())
                chests_previous = sum(sessions[-2]['chests'].values())

                color = sign(chests_gathered - chests_previous) + 1
                screen.addstr(f"{chests_gathered}", colors[("red", "yellow", "green")[color]])
                screen.addstr(" | ")


                for chest in tuple(sessions[-1]["chests"].keys())[::-1]:
                    chests_gathered = sessions[-1]["chests"][chest]
                    chests_previous = sessions[-2]["chests"][chest]

                    if chests_gathered == 0:
                        continue

                    color = sign(chests_gathered - chests_previous) + 1
                    screen.addstr(f"{chests_icons[chest]}", colors[("red", "yellow", "green")[color]])
                    screen.addstr(f" {chests_gathered}  ")

            case "resources":
                for resource in ("ki", "totalgp", "crystals"):
                    color = sign(sessions[-1]['resources'][resource] - sessions[-2]['resources'][resource]) + 1
                    screen.addstr(f"{resources_icons[resource]} ", colors[("red", "yellow", "green")[color]])
                    screen.addstr(f"{sessions[-1]['resources'][resource]:,}  ")

            case "ssrpga":
                screen.addstr(f"launching {len(sessions) + 1:0>4} session of ssrpga", colors["yellow"])
                screen.refresh()

                save()
                session = eval(check_output([executable, "ssrpgauto.py"]))
                sessions.append(session)
                save()

                offset = 0
                state = "wait"

            case "input":
                screen.addstr(f"> {action}")

                for suggestion in action_suggestions:
                    if suggestion.startswith(action):
                        screen.addstr(f"{suggestion[len(action):]}", colors["white"] | curses.A_DIM)
                        break

        # Check input
        try:
            wch = screen.getkey()  # Can be get_wch()

            if isinstance(wch, str) and len(wch) == 1:
                action += wch

            else:
                wch = chr(0)

        except curses.error:
            wch = chr(0)

        # Parse input
        match ord(wch):
            case 127:  # Backspace
                action = action[:-2]

                if action == "":
                    state = "wait"

            case 27:  # Escape
                save()
                break

            case 9:  # Tab
                action = action[:-1]  # Remove tab sign

                # Autocomplete suggestion on tab
                for suggestion in action_suggestions:
                    if suggestion.startswith(action):
                        action = suggestion
            
            case 10:  # Enter
                action = action[:-1]  # Remove enter sign

                # Autocomplete current suggestion on enter
                if action != "":
                    for suggestion in action_suggestions:
                        if suggestion.startswith(action):
                            action = suggestion
                            break

                commands = action.split()
                
                action = ""

                if not commands:
                    state = "wait"
                    continue

                # Execute command
                match commands[0]:
                    case "ssrpga" | "ss":
                        state = "ssrpga"
                    
                    case "stats":
                        check_output([executable, 'stats.py'])
                        state = "wait"

                    case "chests" | "c":
                        if len(sessions) < 2:
                            state = "not available"
                        else:
                            state = "chests"

                    case "resources" | "r":
                        if len(sessions) < 2:
                            state = "not available"
                        else:
                            state = "resources"
                        
                    case "timeout" | "t":
                        if len(commands) >= 2:
                            if commands[1].isalnum():
                                timeout = int(commands[1])
                                screen.timeout(timeout)
                        else:
                            timeout = 1000
                        screen.timeout(timeout)
                        state = "wait"

                    case "lock" | "l":
                        unlocked = not unlocked
                        state = "wait"

                    case "offset" | "o":
                        if len(commands) >= 2:
                            offset = parse(' '.join(commands[1:]))
                            screen.timeout(timeout)
                        else:
                            offset = 0
                        state = "wait"

                    case _:
                        state = "wait"

        if action != "":
            state = "input"

curses.wrapper(main)
# Exit location names:
#   temple
#   icy_ridge
#   boiling_mines
#   haunted_halls
#   mushroom_forest
#   caves_of_fear
#   deadwod_canyon
#   rocky_plateau

exit_location = ("rocky_plateau", "15")
ss_launcher = "Stone Story RPG.app"
is_retina = True

is_event_mode = True  # Make playthrough time half shorter
playthroughs = {
    "temple_17": "8h 4m",
    "icy_ridge_15": "6h 4m",
    "boiling_mines_15": "8h 54m",
    "haunted_halls_20": "6h 9m",
    "mushroom_forest_20": "11h 49m",
    "caves_of_fear_15": "3h 57m",
    "deadwood_canyon_15": "5h 25m",
    "rocky_plateau_15": "8h 47m",
}

# Designed for 1470 x 956 screen
regions = {  # (x, y, w, h)
    "chest_frame": (365, 195, 720, 605),
    "chest_counts": (420, 495, 620, 47),
    "shop_resources": (183, 273, 203, 273),
}

scroll_to = {
    "temple": "scrollar_top",
    "icy_ridge": "scrollar_top",
    "boiling_mines": "scrollbar_upper_half",
    "haunted_halls": "scrollbar_upper_half",
    "mushroom_forest": "scrollbar_center",
    "caves_of_fear": "scrollbar_bottom",
    "deadwod_canyon": "scrollbar_bottom",
    "rocky_plateau": "scrollbar_bottom",
}

points = {  # (x, y)
    "screen": {
        "bottom_right": (1470, 956),
        "center": (735, 478),
    },
    "main": {
        "start_button": (350, 620),
        "exit_button": (350, 760),
    },
    "locations": {
        "locations_button": (235, 170),
        "workbench_button": (235, 340),
        "items_button": (235, 515),
        "quest_stone_button": (235, 690),

        "chests_gatnered_ok_button": (735, 720),

        "farm_offline_button": (1060, 790),
        "farm_explore_button": (790, 790),

        "unsafe_top": (985, 200),
        "unsafe_center": (985, 480),
        "unsafe_bottom": (985, 830),

        "scrollar_top": (1295, 95),
        "scrollbar_upper_half": (1295, 375),
        "scrollbar_shops": (1295, 580),
        "scrollbar_center": (1295, 760),
        "scrollbar_bottom": (1295, 930),

        "hot_key_shop_location_button": (985, 585),
        "mushroom_shop_location_button": (985, 790),
        "mushroom_shop_restocked_red_pixel": (907, 781),

        "temple_button": (985, 235),
        "icy_ridge_button": (985, 655),
        "boiling_mines_button": (985, 315),
        "haunted_halls_button": (985, 725),
        "mushroom_forest_button": (985, 515),
        "caves_of_fear_button": (985, 445),
        "deadwod_canyon_button": (985, 655),
        "rocky_plateau_button": (985, 860),
    },
    "mushroom_shop": {
        "items": {
            "item_1": (715, 205),
            "item_2": (1120, 205),
            "item_3": (715, 410),
            "item_4": (1120, 410),
            "item_5": (715, 620),
            "item_6": (1120, 620),
        },
        "chests": {
            "big": (640, 825),
            "omega": (910, 825),
            "delta": (1180, 825),
        },
        "buy_item_all_button": (1175, 520),
        "buy_chest_button": (1175, 685),
        "go_back_button": (180, 165),
    },
    "hot_key_shop": {
        "daily_crystall": (660, 420),
        "go_back_button": (220, 170),
        "buy_item_button": (1295, 375),
        "item_card_outside_of_any_window": (45, 55),
    },
    "items": {
        "top_left_item": (525, 375),
        "top_left_item_open_all": (620, 515),
        "top_left_second_item": (715, 375),
        "top_left_second_item_open_all": (815, 515),
        "chests_opening_skip_button": (715, 860),
        "chests_opening_outside_of_any_window": (235, 755),
        "scrollbar_top": (1410, 305),
        "scrollbar_bottom": (1410, 930),

        "moonbloom_info": (525, 515),
        "moonbloom_mutate": (735, 440),

        "bottom_cell_1": (525, 890),
        "bottom_cell_2": (715, 720),
        "bottom_cell_3": (910, 720),
        "bottom_cell_4": (1100, 720),
        "bottom_cell_5": (1295, 720),
    },
    "anvil": {
        "left_fuse_item": (560, 235),
        "right_fuse_item": (890, 240),
        "fuse_button": (715, 235),
        "scrollbar_top": (1215, 450),
        "scrollbar_bottom": (1215, 930),
        "inventory_right_slot": (1100, 512),
        "outside_of_any_window": (40, 890),
    },
    "brewing": {
        "brew_tar_button": (965, 550),
        "brew_stone_button": (505, 550),
        "brew_button": (720, 170),
        "brew_confirm_refill": (540, 655),
        "outside_of_any_window": (40, 890),
    }
}
from time import time

from settings import *
from controller import *

init_mouse()

start_time = time()
session = {}

# Run game
launch(ss_launcher)
wait(3)
wait_for('logo_part.png')
click(points["screen"]["center"])
click(points["main"]["start_button"])

# Gather all chests
chests = {
    "pinata": 0,
    "emerald_egg": 0,
    "delta": 0,
    "omega": 0,
    "big": 0,
    "common": 0,
}

wait_for("chests_gained_part.png")

screen = screenshot(filename=f"examples/Chests/{int(start_time)}.png")
chests_gathered = recognize(screenshot(regions["chest_counts"]))

for chest in chests:
    sample = f"chest_{chest}.png"
    confidence = 0.629 if chest == "emerald_egg" else 0.90
    region = scale(regions["chest_frame"], 2 if is_retina else 1)

    if locate(sample, screen, confidence, region):
        table = {ord(i): None for i in ".×xхXХ "}
        chests[chest] = int(chests_gathered.pop().translate(table))

    if not len(chests_gathered):
        break

click(points["locations"]["chests_gatnered_ok_button"])

# Open all chests in inventory
click(points["locations"]["items_button"], t2=0.5)
click(points["items"]["top_left_second_item"])
click(points["items"]["top_left_second_item_open_all"])
click(points["items"]["chests_opening_skip_button"])
wait_loot(points["items"]["chests_opening_outside_of_any_window"])

# Check moonbloom
moonbloom_opened = False

screen = screenshot(filename=f"examples/Moonblooms/{int(start_time)}.png")
moonbloom_sample = 'moonbloom_part.png'

if locate(moonbloom_sample, screen):
    click(points["items"]["top_left_item"])
    click(points["items"]["moonbloom_info"])
    click(points["items"]["moonbloom_mutate"], t2=4)

    moonbloom_opened = True

# Go to main menu
click(points["locations"]["locations_button"])
hold(points["locations"]["scrollbar_shops"])

# Buy all items in mushroom shop (if it refilled)
mushroom_shop_visited = pixel(
    scale(
        points["locations"]["mushroom_shop_restocked_red_pixel"],
        2 if is_retina else 1
    )
) != (0, 0, 0)

if mushroom_shop_visited:
    click(points["locations"]["mushroom_shop_location_button"], t2=0.5)

    for item in points["mushroom_shop"]["items"]:
        click(points["mushroom_shop"]["items"][item])
        click(points["mushroom_shop"]["buy_item_all_button"])

    for chest in points["mushroom_shop"]["chests"]:
        click(points["mushroom_shop"]["chests"][chest])
        click(points["mushroom_shop"]["buy_chest_button"])

        wait_loot(points["items"]["chests_opening_outside_of_any_window"])

    click(points["mushroom_shop"]["go_back_button"], t2=0.5)

# Gather daily crystall and check resources
resources = {
    "stone": 0,
    "wood": 0,
    "tar": 0,
    "bronze": 0,
    "ki": 0,
    "crystals": 0,
    "totalgp": 0,
}

click(points["locations"]["hot_key_shop_location_button"], t2=3.3)
click(points["hot_key_shop"]["daily_crystall"])

resources_gathered = recognize(screenshot(
    regions["shop_resources"],
    filename=f"examples/Resources/{int(start_time)}.png")
)

for resource in resources:
    resources[resource] = int(resources_gathered.pop(0))

click(points["hot_key_shop"]["go_back_button"], t2=0.5)

# Set location to offline farm
hold(points["locations"][scroll_to[exit_location[0]]])
click(points["locations"][exit_location[0] + "_button"], t2=0.5)
click(points["locations"]["farm_offline_button"], t2=3.5)
click(points["main"]["exit_button"])

info = {
    "mushroom_shop_visited": mushroom_shop_visited,
    "moonbloom_opened": moonbloom_opened,
    "run_time": time() - start_time,
    "exit_time": time(),
    "exit_location": "_".join(exit_location),
}

session["chests"] = chests
session["resources"] = resources
session["info"] = info

print(session)
import time

from settings import *
from controller import *

init_mouse()

enchantments = 0

time.sleep(3)
while True:
    pos = locate("enchantment_border.png", confidence=0.95)

    if not pos:
        print(f"Done with {enchantments} enchantments")
        break

    click(scale(pos, 0.5 if is_retina else 1))  # Pick enchantment to left fuse slot
    hold(points["anvil"]["scrollbar_bottom"])
    click(points["anvil"]["inventory_right_slot"])
    click(points["anvil"]["fuse_button"], t2=2.7)    
    click(points["anvil"]["outside_of_any_window"])  # Close item window
    click(points["anvil"]["left_fuse_item"])  # Remove combined item
    hold(points["anvil"]["scrollbar_top"])
    scroll(0, -25)

    enchantments += 1
saved = True
timestamp = 1750626000.0
activities = []from math import pi, sin, cos

import numpy
from PIL import Image

import save
from setup import setup

from utils import h, d, w

ARGS, ACTIVITIES = setup("circles")
all_experiment_time = save.timestamp - save.activities[0][1]
experiment_start_time = save.activities[0][1]

start_radius = ARGS["START_RADIUS"]
image_side = (
    round((start_radius + all_experiment_time/w))*2 + 8
    if ARGS["IMAGE_SIDE"] == "auto" else
    ARGS["IMAGE_SIDE"]
)

# Create image canvas
image = numpy.zeros((image_side, image_side, 3), dtype=numpy.uint8)
image[:][:] = ARGS["COLOR_BG"]

# Form dots
for i, activity in enumerate(save.activities):
    activity_name, timestamp, *_ = activity
    if activity_name == ARGS["VOID"]: continue
    
    x = (timestamp + ARGS["UTC_OFFSET"]) % d / h

    if i != len(save.activities) - 1: 
        days = (timestamp - experiment_start_time) / d
    else: 
        days = (save.timestamp - experiment_start_time) / d

    y = round(cos(pi * x / 12)*(start_radius + days/7) - image_side/2)
    x = round(sin(pi * x / 12)*(start_radius + days/7) + image_side/2)
    
    # if activity == "Сон":
    image[x][y] = ACTIVITIES[activity_name]

image_side *= ARGS["IMAGE_SCALE"]

image = Image.fromarray(image)
image = image.transpose(Image.Transpose.ROTATE_90)
image = image.resize((image_side, image_side), resample=Image.Resampling.BOX)

if ARGS["IMAGE"]:
    image.save(f"circles.png")

if not ARGS["SILENT"]:
    image.show()
from datetime import datetime

import matplotlib.pyplot as plt
from matplotlib.patches import Patch

import save
from setup import setup

from utils import m, h, d, w
from utils import generate_activites_times
from utils import normalize_color

ARGS, ACTIVITIES = setup("map")
activities_times = generate_activites_times(save.activities, save.timestamp)

# Create plot canvas
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(ARGS["PLOT_WIDTH"], ARGS["PLOT_HEIGHT"]), 
)

fig.canvas.manager.set_window_title("Карта сохранения")
ax = list(axs.items())

all_experiment_time = sum([sum(activities_times[i]) for i in activities_times])
save_activities = set([i[0] for i in save.activities])

average_day = {
    activity_name: sum(activities_times[activity_name]) for activity_name in ACTIVITIES 
    if activity_name != ARGS["VOID"] and activity_name in save_activities
}

def bar_constructor(x, y):
    global offset

    if activity[0] != ARGS["VOID"]:
        ax[0][1].bar(
            x=x,
            bottom=offset,
            width=1,
            height=y,
            linewidth=.5,
            color=normalize_color(ACTIVITIES[activity[0]])
        )

    offset += y

# Generate all parts and add it to plot
experiment_start_time = save.activities[0][1]
offset = experiment_start_time % d + ARGS["UTC_OFFSET"]
days = 1

for activity in save.activities:
    # Create one bar
    if activities_times[activity[0]][0] <= d - offset:
        bar_constructor(days, activities_times[activity[0]][0])

    else:
        to_distribute = activities_times[activity[0]][0]
        to_distribute -= d - offset
        bar_constructor(days, d - offset)

        # Create bars, separated by days
        while to_distribute != 0:
            days += 1
            offset = 0

            if to_distribute >= d:
                bar_constructor(days, d)
                to_distribute -= d
            else:
                bar_constructor(days, to_distribute)
                to_distribute = 0

    activities_times[activity[0]].pop(0)

if ARGS["SHOW_LEGEND"]:
    legend_elements = [
        Patch(
            facecolor=normalize_color(ACTIVITIES[i]),
            edgecolor="black",
            linewidth=.5,
            label=i
        ) for i in average_day if i != ARGS["VOID"]
    ]
    
    # ax[0][1].legend(handles=legend_elements, ncol=ARGS["LEGEND_COLUMNS"], loc="lower left")

start_day = datetime.fromtimestamp(save.activities[0][1]).weekday()
start_hour = experiment_start_time%(d) + ARGS["UTC_OFFSET"]

days_of_week = ("Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс")

def format_coord(x, y):
    x = int(x-.5)
    y = round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)
    
    selected_time = x*d + y*h + experiment_start_time - start_hour
    
    # Form bar info
    bar_info = ""
    for k, i in enumerate(save.activities):
        if i[1] >= selected_time or not save.activities[0][1] <= selected_time <= save.timestamp: break
        pivot = save.timestamp if len(save.activities)-1 == k else save.activities[k+1][1]
        
        bar_info = f"{i[0]}"
        bar_info += f" ({i[-1]})" if i[-1] else ""
        bar_info += (
            f" ({round((pivot - i[1]) / h, 1)}ч)\n" if (pivot - i[1]) / h > 1 else
            f" ({round((pivot - i[1]) / m, 1)}м)\n"
        )
        
    # Form position info
    position_info = (
        f"x={days_of_week[(x+start_day)%7]}, {y=}ч "
        f"({round((selected_time - experiment_start_time) // w + 1)} неделя)"
    )
        
    return bar_info + position_info


import re
from os import stat
from pathlib import Path
from datetime import datetime

from matplotlib import ticker
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.dates import DateFormatter

from setup import setup

ARGS_C = {'path': '../../../9 Блокнот', 'exclude_frontmatter': True, 'exclude_date': True, 'search': ['../../../9 Блокнот/2023', '../../../9 Блокнот/2024'], 'sort_values': False, 'utc_offset': 10800, 'notes_all': True, 'notes_daily': False, 'notes_dreams': False, 'notes_symmary': False, 'notes_other': False}

groups = {
    "daily": {
        "re": r"[\d\-]+\s\w+\s\([\d\-]+\)",
        "allowed": ARGS_C["notes_daily"],
        "color": "tab:orange",
        "legend_title": "Дейли",
    },
    "symmary": {
        "re": r"(И|и)тоги\s.+",
        "tag": "Итоги",
        "allowed": ARGS_C["notes_symmary"],
        "color": "tab:green",
        "legend_title": "Итоги",
    },
    "dreams": {
        "re": r"(Сон|Сны)\s.+",
        "allowed": ARGS_C["notes_dreams"],
        "color": "tab:purple",
        "legend_title": "Сны",
    },
    "other": {
        "re": r".+",
        "allowed": ARGS_C["notes_other"],
        "color": "tab:blue",
        "legend_title": "Другое",
    },
}

day = 24 * 3600

if ARGS_C["notes_all"]:
    for group in groups:
        groups[group]["allowed"] = True

def get_file_name(file, extension):
    return str(file).split('/')[-1].replace(extension, '')

def get_files(paths, search_filter):
    files = list()
    
    for path in paths:
        directory = Path(path)
        files.extend(list(directory.rglob(search_filter)))
    
    return sorted(files, key=lambda path: stat(path).st_birthtime)

md_files = get_files(ARGS_C["search"], "*.md")

data = []
creation_times = 0

# File words
for file_path in md_files:
    file_name = get_file_name(file_path, ".md")
    file_content = open(file_path, "r").read()
    
    if ARGS_C["exclude_frontmatter"]:
        file_content = re.sub(r"^---(.|\n)+?---", '', file_content)
        
    if ARGS_C["exclude_date"]:
        file_content = re.sub(r"^\n\*\*.+\n", '', file_content)
    
    file_header = ''.join([''.join(match) for match in re.findall(r"(^---(.|\n)+?---)", file_content)])
    
    # Get file group
    for group in groups:
        if "re" in groups[group]:
            if re.match(groups[group]["re"], file_name):
                file_group = group
                break
            
        elif "tag" in groups[group]:
            if group[group]["tag"] in file_header:
                file_group = group
                break
    
    # Add file data to statistics
    if groups[file_group]["allowed"]:
        creation_time = (stat(file_path).st_birthtime + ARGS_C["utc_offset"]) % day
        creation_date = (stat(file_path).st_birthtime - experiment_start_time) // day + 2
                         
        data.append((creation_date, creation_time, file_group))
        # print(file_words, file_path)
        
if ARGS_C["sort_values"]:
    data = sorted(data, key=lambda val: val[1], reverse=True)

# Split all data on lists
files = [i[0] for i in data]
creation_times = [i[1] for i in data]
colors = [groups[i[2]]["color"] for i in data]

# Create plot
# fig, axs = plt.subplot_mosaic(
#     [["main"]],
#     figsize=(13.5, 5.7), 
# )

# fig.canvas.manager.set_window_title("Время создания файлов")
# ax = list(axs.items())

legend_elements_2 = [
    Patch(
        facecolor=groups[group]["color"],
        edgecolor="black",
        linewidth=.5,
        label=groups[group]["legend_title"],
    ) for group in groups if groups[group]["allowed"]
]
# legend_elements.extend(legend_elements_2)
# ax[0][1].legend(handles=legend_elements)

# def format_coord(x, y):
#     x = int(x+.5)
    
#     return f"{get_file_name(files[x], '.md')}\nВремя создания: {creation_times[x].strftime("%H:%M:%S")}"

# ax[0][1].format_coord = format_coord
ax[0][1].scatter(files, creation_times, color=colors, edgecolor="black", linewidth=1)
# ax[0][1].legend()
# ax[0][1].set_xlim(-.5, len(creation_times) - .5)
# ax[0][1].xaxis.set_visible(False)

# ax[0][1].set_ylim(datetime.fromtimestamp(-ARGS["utc_offset"]), datetime.fromtimestamp(day - ARGS["utc_offset"]))
# ax[0][1].yaxis.set_major_locator(ticker.MultipleLocator(1 / 10))
# ax[0][1].yaxis.set_major_formatter(DateFormatter("%H:%M"))

# plt.tight_layout()
# plt.show()





ax[0][1].format_coord = format_coord

ax[0][1].set_xticks(range(1, days+1, 7), [(i+start_day) for i in range(1, days+1, 7)])
ax[0][1].set_xlim(.5, days + .5)
ax[0][1].xaxis.set_major_formatter(lambda x, _: int(x-.5)//7+1)

ax[0][1].set_yticks(range(0, d+1, d//10), [f"{i}%" for i in range(0, 101, 10)])
ax[0][1].set_ylim(0, d)
ax[0][1].yaxis.set_major_formatter(lambda y, _: f"{round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)}ч")

plt.tight_layout()
plt.savefig(f"map.png", bbox_inches="tight")

if not ARGS["SILENT"]:
    plt.show()
from os import system, get_terminal_size
from utils import *

system("clear")

"""
24 min - block
.4 h
Начать новый этап:
{green}1{white}: Сон
{green}2{white}: Отдых
{green}3{white}: Другое
{green}4{white}: Пары
{green}5{white}: Метро
{green}6{white}: Домашка

{green}e{white}: Завершить сессию
{green}d{white}: Удалить последнее занятие
{green}c{white}: Изменить время последнего занятия
{green}i{white}: Добавить подпись к последнему занятию
"""

data = f"""
{magenta}52{white} Отдых 22:00:00 ({cyan}03:49:08{white})
{magenta}53{white} Сон 01:49:08 ({cyan}11:25:31{white})
{magenta}54{white} Отдых 13:14:40 ({cyan}05:32:20{white})
{magenta}55{white} Другое 18:47:01 ({cyan}03:46:08{white})
{magenta}56{white} Отдых 22:33:10 ({cyan}03:01:48{white})
{magenta}57{white} Сон 01:34:58 ({cyan}10:53:07{white}) 
"""

print(data)
import matplotlib.pyplot as plt
from matplotlib.patches import Patch

from datetime import datetime

import save
from setup import setup

from utils import m, h, d, w
from utils import generate_activites_times
from utils import normalize_color

FREE = 0
FREE_FULL = 0

ARGS, ACTIVITIES = setup("map")
activities_times = generate_activites_times(save.activities, save.timestamp)

# create plot canvas
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(ARGS["PLOT_WIDTH"], ARGS["PLOT_HEIGHT"]), 
)

fig.canvas.manager.set_window_title("Карта сохранения")
ax = list(axs.items())

all_experiment_time = sum([sum(activities_times[i]) for i in activities_times])
save_activities = set([i[0] for i in save.activities])

average_day = {
    activity_name: sum(activities_times[activity_name]) for activity_name in ACTIVITIES 
    if activity_name != ARGS["VOID"] and activity_name in save_activities
}

def bar_constructor(x, y):
    global offset

    if activity[0] != ARGS["VOID"]:
        ax[0][1].bar(
            x=x,
            bottom=offset,
            width=1,
            height=y,
            linewidth=.5,
            color=normalize_color(ACTIVITIES[activity[0]])
        )

    offset += y

# generate all parts and add it to plot
free = True
free_full = True

experiment_start_time = save.activities[0][1]
offset = experiment_start_time % d + ARGS["UTC_OFFSET"]
days = 1

for activity in save.activities:
    # create one bar
    if activities_times[activity[0]][0] <= d - offset:
        bar_constructor(days, activities_times[activity[0]][0])
        if activity[0] in ("Пары"):
            free = False
        if activity[0] in ("Домашка", "Пары"):
            free_full = False

    else:
        to_distribute = activities_times[activity[0]][0]
        to_distribute -= d - offset
        bar_constructor(days, d - offset)
        if activity[0] in ("Пары"):
            free = False
        if activity[0] in ("Домашка", "Пары"):
            free_full = False
        
        # create bars, separated by days
        while to_distribute != 0:
            days += 1
            offset = 0
            
            if free: FREE += 1
            if free_full: FREE_FULL += 1
            
            free = True
            free_full = True

            if to_distribute >= d:
                bar_constructor(days, d)
                if activity[0] in ("Пары"):
                    free = False
                if activity[0] in ("Домашка", "Пары"):
                    free_full = False
                to_distribute -= d
            else:
                bar_constructor(days, to_distribute)
                if activity[0] in ("Пары"):
                    free = False
                if activity[0] in ("Домашка", "Пары"):
                    free_full = False
                to_distribute = 0

    activities_times[activity[0]].pop(0)

if ARGS["SHOW_LEGEND"]:
    legend_elements = [
        Patch(
            facecolor=normalize_color(ACTIVITIES[i]),
            edgecolor="black",
            linewidth=.5,
            label=i
        ) for i in average_day if i != ARGS["VOID"]
    ]
    
    ax[0][1].legend(handles=legend_elements, ncol=ARGS["LEGEND_COLUMNS"], loc="lower left")

start_day = datetime.fromtimestamp(save.activities[0][1]).weekday()
start_hour = experiment_start_time%(d) + ARGS["UTC_OFFSET"]

days_of_week = ("Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс")

def format_coord(x, y):
    x = int(x-.5)
    y = round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)
    
    selected_time = x*d + y*h + experiment_start_time - start_hour
    
    # form bar info
    bar_info = ""
    for k, i in enumerate(save.activities):
        if i[1] >= selected_time or not save.activities[0][1] <= selected_time <= save.timestamp: break
        pivot = save.timestamp if len(save.activities)-1 == k else save.activities[k+1][1]
        
        bar_info = f"{i[0]}"
        bar_info += f" ({i[-1]})" if i[-1] else ""
        bar_info += (
            f" ({round((pivot - i[1]) / h, 1)}ч)\n" if (pivot - i[1]) / h > 1 else
            f" ({round((pivot - i[1]) / m, 1)}м)\n"
        )
        
    # form position info
    position_info = (
        f"x={days_of_week[(x+start_day)%7]}, {y=}ч "
        f"({round((selected_time - experiment_start_time) // w + 1)} неделя)"
    )
        
    return bar_info + position_info

ax[0][1].format_coord = format_coord

ax[0][1].set_xticks(range(1, days+1, 7), [(i+start_day) for i in range(1, days+1, 7)])
ax[0][1].set_xlim(.5, days + .5)
ax[0][1].xaxis.set_major_formatter(lambda x, _: int(x-.5)//7+1)

ax[0][1].set_yticks(range(0, d+1, d//10), [f"{i}%" for i in range(0, 101, 10)])
ax[0][1].set_ylim(0, d)
ax[0][1].yaxis.set_major_formatter(lambda y, _: f"{round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)}ч")

print(f"{FREE=} ({FREE/days:.2%}) {FREE_FULL=} ({FREE_FULL/days:.2%}) {days=}")

plt.tight_layout()
plt.savefig(f"map.png", bbox_inches="tight")

if not ARGS["SILENT"]:
    plt.show()
"""draft"""

from statistics import median

import save
from setup import setup

from utils import s, m, h, d, w
from utils import color, cyan, magenta, green, red, white
from utils import generate_activites_times
from utils import stages_formatter
from utils import timedelta

ARGS, ACTIVITIES = setup("tracker")
save_activities = set([i[0] for i in save.activities])

activities_times = generate_activites_times(save.activities, save.timestamp)
all_experiment_time = save.timestamp - save.activities[0][1]

# generate statistics
stats = {}
for activity_name in ACTIVITIES:
    if activity_name not in save_activities:
        continue
    
    activity_time = sum(activities_times[activity_name])
    activity_counter = len(activities_times[activity_name])
    
    activity_percentage = activity_time / all_experiment_time
    activity_mean_stage = activity_time / activity_counter
    activity_mean_daily = activity_percentage * d
    
    # add to stats
    stats[activity_name] = {}
    print(
        "Сессий",
        color(
            magenta,  
            len(activities_times[activity_name])
        )
    )
    stats[activity_name]["Cессий в день"] = round(len(activities_times[activity_name])/(all_experiment_time/d), 1)

    stats[activity_name]["Плотность по времени"] = f"{activity_percentage:.2%}"
    stats[activity_name]["Плотность по этапам"] = f"{len(activities_times[activity_name]) / len(save.activities):.2%}"

    stats[activity_name]["Общее время"] = activity_time
    stats[activity_name]["В среднем за этап"] = activity_mean_stage
    stats[activity_name]["В среднем за день"] = activity_mean_daily
    stats[activity_name]["Медиана за этап"] = median(activities_times[activity_name])
    
    stats[activity_name]["Максимальный этап"] = max(activities_times[activity_name])
    stats[activity_name]["Минимальный этап"]  = min(activities_times[activity_name])

# output
for activity_name in stats:
    print(activity_name)
    for stat in stats[activity_name]:
        print(stat, stats[activity_name][stat])
    print()

# summary
all_EEE = []
for i in activities_times:
    all_EEE.extend(activities_times[i])

print("Итого")
print("Cессий:", len(save.activities))
print("Cессий в день:", round(len(save.activities)/(all_experiment_time/d), 1))
print("Общее время:", timedelta(all_experiment_time))
print("В среднем за этап:", timedelta(all_experiment_time / len(save.activities)))
print("Медиана за этап:", timedelta(median(all_EEE)))
from math import ceil
from datetime import datetime

import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter, MultipleLocator
from matplotlib.patches import Patch

import save
from setup import setup

from utils import m, h, d, w
from utils import generate_activites_times
from utils import normalize_color
from utils import weekdays, months

ARGS, ACTIVITIES = setup("barh")
activities_times = generate_activites_times(save.activities, save.timestamp)

save_activities = set([i[0] for i in save.activities])
average_day = {
    activity_name: sum(activities_times[activity_name])
    for activity_name in ACTIVITIES
    if activity_name in save_activities
}

# Create plot canvas
fig, axs = plt.subplot_mosaic(
    (["main"], ["average"]),
    figsize=(ARGS["PLOT_WIDTH"], ARGS["PLOT_HEIGHT"]), 
    gridspec_kw={"height_ratios": (14, 1)}
)

fig.canvas.manager.set_window_title("Распределение времени")
ax = list(axs.items())

# First plot - bars for each days
def bar_constructor(x, y):
    global offset

    if activity[0] != ARGS["VOID"]:
        ax[0][1].barh(
            left=offset,
            y=y,
            width=x,
            height=1,
            edgecolor="black",
            linewidth=.5,
            color=normalize_color(ACTIVITIES[activity[0]])
        )
        
        if x >= d * ARGS["LABEL_TRESHOLD"]:
            ax[0][1].text(
                x=x/2 + offset,
                y=y,
                s=f"{round(x/h) if round(x/h, 1) == round(x/h) else round(x/h, 1)}ч",
                va="center",
                ha="center",
                clip_on=True
            )

    offset += x

# Generate all parts and add it to plot
experiment_start_time = save.activities[0][1]
all_experiment_time = save.timestamp - experiment_start_time

offset = (experiment_start_time + ARGS["UTC_OFFSET"]) % d
days = 1

for activity in save.activities:
    # Create one bar
    if activities_times[activity[0]][0] <= d - offset:
        bar_constructor(activities_times[activity[0]][0], days)

    else:
        to_distribute = activities_times[activity[0]][0]
        to_distribute -= d - offset
        bar_constructor(d - offset, days)

        # Create bars, separated by days
        while to_distribute != 0:
            days += 1
            offset = 0

            if to_distribute >= d:
                bar_constructor(d, days)
                to_distribute -= d
            else:
                bar_constructor(to_distribute, days)
                to_distribute = 0

    activities_times[activity[0]].pop(0)

if ARGS["SHOW_LEGEND"]:
    legend_elements = [
        Patch(
            facecolor=normalize_color(ACTIVITIES[i]),
            edgecolor="black",
            linewidth=.5,
            label=i
        ) for i in average_day if i != ARGS["VOID"]
    ]
    
    ax[0][1].legend(handles=legend_elements, ncol=ARGS["LEGEND_COLUMNS"], loc="upper left")

start_day = datetime.fromtimestamp(save.activities[0][1]).weekday()
start_hour = experiment_start_time % d + ARGS["UTC_OFFSET"]

if start_hour == d:
    start_hour = 0

def format_coord(x, y):
    x = round(x/h) if round(x/h, 1) == round(x/h) else round(x/h, 1)
    y = int(y-.5)
    
    selected_time = y*d + x*h + experiment_start_time - start_hour
    
    # Form bar info
    bar_info = ""
    for k, i in enumerate(save.activities):
        if i[1] >= selected_time or not save.activities[0][1] <= selected_time <= save.timestamp: break
        pivot = save.timestamp if len(save.activities)-1 == k else save.activities[k+1][1]
        
        bar_info = f"{i[0]}"
        bar_info += f" ({i[-1]})" if i[-1] else ""
        bar_info += (
            f" ({round((pivot - i[1]) / h, 1)}ч)\n" if (pivot - i[1]) / h >= 1 else
            f" ({round((pivot - i[1]) / m, 1)}м)\n"
        )
        
    # Form position info    
    month = months[datetime.fromtimestamp(selected_time).month - 1]
    day = datetime.fromtimestamp(selected_time).day
    week = round((selected_time - experiment_start_time) // w + 1)
    
    position_info = (
        f"{x=}ч, y={weekdays[(y+start_day)%7]} "
        f"({day} {month}, {week} неделя)"
    )
        
    return bar_info + position_info

view_shift = ceil((all_experiment_time+start_hour) // d) - 13.5 if ceil((all_experiment_time) / w) > 2 else .5

ax[0][1].format_coord = format_coord

ax[0][1].set_xticks(range(0, d+1, d//10), [f"{i}%" for i in range(0, 101, 10)])
ax[0][1].set_xlim(0, d)
ax[0][1].xaxis.set_major_formatter(lambda x, _: f"{round(x/h) if round(x/h, 1) == round(x/h) else round(x/h, 1)}ч")

ax[0][1].set_yticks(range(1, days+1), [weekdays[(i+start_day)%7] for i in range(days)])
ax[0][1].set_ylim(view_shift, 15 + view_shift)
ax[0][1].invert_yaxis()
ax[0][1].yaxis.set_major_formatter(lambda y, _: weekdays[(int(y-.5)+start_day)%7])

# Second plot - average time
offset = 0

for activity in average_day:
    if activity != ARGS["VOID"]:
        ax[1][1].barh(
            left=offset,
            y=1,
            width=average_day[activity],
            height=1,
            edgecolor="black",
            color=normalize_color(ACTIVITIES[activity]),
            linewidth=.5
        )

        if average_day[activity] >= all_experiment_time * ARGS["AV_LABEL_TRESHOLD"]:
            ax[1][1].text(
                y=1,
                x=(average_day[activity]/2+offset),
                s=f"{round(average_day[activity]/all_experiment_time*100, 1)}%",
                va="center",
                ha="center",
                clip_on=True
            )

    offset += average_day[activity]

def format_coord(x, y):
    time_offset = 0
    
    # Form bar info
    bar_info = ""
    for activity in average_day:
        if time_offset + average_day[activity] > x:
            bar_info = f"{activity} ({round(average_day[activity]/all_experiment_time*100, 1)}%)\n"
            break
        
        time_offset += average_day[activity]
    
    # Form position info
    position_info = f"x={round(x/all_experiment_time*100, 1)}%, y=AV"
        
    return bar_info + position_info

average_time_max = all_experiment_time - (average_day[ARGS["VOID"]] if ARGS["HIDE_VOID"] else 0)

ax[1][1].format_coord = format_coord

ax[1][1].set_xlim(0, average_time_max)
ax[1][1].xaxis.set_major_formatter(PercentFormatter(all_experiment_time))
ax[1][1].xaxis.set_major_locator(MultipleLocator(average_time_max / 10))

ax[1][1].set_yticks((1,), ("AV",))
ax[1][1].set_ylim(.5, 1.5)
ax[1][1].yaxis.set_major_formatter(lambda *_: "AV")

plt.tight_layout()

if ARGS["IMAGE"]:
    plt.savefig(f"barh.png", bbox_inches="tight")

if not ARGS["SILENT"]:
    plt.show()
from datetime import datetime

import matplotlib.pyplot as plt
from matplotlib.patches import Patch

import save
from setup import setup

from utils import m, h, d, w
from utils import generate_activites_times
from utils import normalize_color
from utils import weekdays, months

ARGS, ACTIVITIES = setup("map")
activities_times = generate_activites_times(save.activities, save.timestamp)

# Create plot canvas
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(ARGS["PLOT_WIDTH"], ARGS["PLOT_HEIGHT"]), 
)

fig.canvas.manager.set_window_title("Карта сохранения")
ax = list(axs.items())

all_experiment_time = sum([sum(activities_times[i]) for i in activities_times])
save_activities = set([i[0] for i in save.activities])

average_day = {
    activity_name: sum(activities_times[activity_name]) for activity_name in ACTIVITIES 
    if activity_name != ARGS["VOID"] and activity_name in save_activities
}

def bar_constructor(x, y):
    global offset

    if activity[0] != ARGS["VOID"]:
        ax[0][1].bar(
            x=x,
            bottom=offset,
            width=1,
            height=y,
            linewidth=.5,
            color=normalize_color(ACTIVITIES[activity[0]])
        )

    offset += y

# Generate all parts and add it to plot
experiment_start_time = save.activities[0][1]
offset = experiment_start_time % d + ARGS["UTC_OFFSET"]
days = 1

for activity in save.activities:
    # Create one bar
    if activities_times[activity[0]][0] <= d - offset:
        bar_constructor(days, activities_times[activity[0]][0])

    else:
        to_distribute = activities_times[activity[0]][0]
        to_distribute -= d - offset
        bar_constructor(days, d - offset)

        # Create bars, separated by days
        while to_distribute != 0:
            days += 1
            offset = 0

            if to_distribute >= d:
                bar_constructor(days, d)
                to_distribute -= d
            else:
                bar_constructor(days, to_distribute)
                to_distribute = 0

    activities_times[activity[0]].pop(0)

if ARGS["SHOW_LEGEND"]:
    legend_elements = [
        Patch(
            facecolor=normalize_color(ACTIVITIES[i]),
            edgecolor="black",
            linewidth=.5,
            label=i
        ) for i in average_day if i != ARGS["VOID"]
    ]
    
    ax[0][1].legend(handles=legend_elements, ncol=ARGS["LEGEND_COLUMNS"], loc="lower left")

start_day = datetime.fromtimestamp(save.activities[0][1]).weekday()
start_hour = experiment_start_time%(d) + ARGS["UTC_OFFSET"]

def format_coord(x, y):
    x = int(x-.5)
    y = round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)
    
    selected_time = x*d + y*h + experiment_start_time - start_hour
    
    # Form bar info
    bar_info = ""
    for k, i in enumerate(save.activities):
        if i[1] >= selected_time or not save.activities[0][1] <= selected_time <= save.timestamp: break
        pivot = save.timestamp if len(save.activities)-1 == k else save.activities[k+1][1]
        
        bar_info = f"{i[0]}"
        bar_info += f" ({i[-1]})" if i[-1] else ""
        bar_info += (
            f" ({round((pivot - i[1]) / h, 1)}ч)\n" if (pivot - i[1]) / h >= 1 else
            f" ({round((pivot - i[1]) / m, 1)}м)\n"
        )
        
    # Form position info
    month = months[datetime.fromtimestamp(selected_time).month - 1]
    day = datetime.fromtimestamp(selected_time).day
    week = round((selected_time - experiment_start_time) // w + 1)
    
    position_info = (
        f"x={weekdays[(x+start_day)%7]}, {y=}ч "
        f"({day} {month}, {week} неделя)"
    )
        
    return bar_info + position_info

ax[0][1].format_coord = format_coord
ax[0][1].margins(0)

ax[0][1].set_xticks(range(1, days+1, 7), [(i+start_day) for i in range(1, days+1, 7)])
ax[0][1].xaxis.set_major_formatter(lambda x, _: int(x-.5)//7+1)

ax[0][1].set_yticks(range(0, d+1, d//10), [f"{i}%" for i in range(0, 101, 10)])
ax[0][1].yaxis.set_major_formatter(lambda y, _: f"{round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)}ч")

plt.tight_layout()

if ARGS["IMAGE"]:
    plt.savefig(f"map.png", bbox_inches="tight")

if not ARGS["SILENT"]:
    plt.show()
import argparse
import tomllib

from time import timezone

def int_or_str(data):
    try:
        return int(data)
    except ValueError:
        return str(data)

def add_argument(argument, parser, ARGS):
    match argument:
        case "help":
            parser.add_argument(
            "--help",
            action="help",
            default=argparse.SUPPRESS,
            help="Show all script startup parameters and exit"
        )

        case "SILENT":
            parser.add_argument(
                "-s", "--silent",
                help="Do not open the created image or plot",
                action="store_const",
                const=not ARGS["SILENT"],
                default=ARGS["SILENT"],
                dest="SILENT"
            )

        case "IMAGE":
            parser.add_argument(
                "-i", "--image",
                help="Do not save plot image",
                action="store_const",
                const=not ARGS["IMAGE"],
                default=ARGS["IMAGE"],
                dest="IMAGE"
            )

        case "CUMULATIVE":
            parser.add_argument(
                "-c",
                help="Display staticics for all time or by week",
                action="store_const",
                const=not ARGS["CUMULATIVE"],
                default=ARGS["CUMULATIVE"],
                dest="CUMULATIVE",
            )

        case "HIDE_VOID":
            parser.add_argument(
                "-v",
                help="Hide void on the density or average plot",
                action="store_const",
                const=not ARGS["HIDE_VOID"],
                default=ARGS["HIDE_VOID"],
                dest="HIDE_VOID"
            )

        case "LABEL_TRESHOLD":
            parser.add_argument(
                "-t",
                help="Threshold for displaying the stage time on the main plot",
                default=ARGS["LABEL_TRESHOLD"],
                type=float,
                dest="LABEL_TRESHOLD"
            )

        case "AV_LABEL_TRESHOLD":
            parser.add_argument(
                "-avt",
                help="Threshold for displaying the stage time on the average plot",
                default=ARGS["AV_LABEL_TRESHOLD"],
                type=float,
                dest="AV_LABEL_TRESHOLD"
            )

        case "SHOW_LEGEND":
            parser.add_argument(
                "-l",
                help="Displaying the plot legend",
                action="store_const",
                const=not ARGS["SHOW_LEGEND"],
                default=ARGS["SHOW_LEGEND"],
                dest="SHOW_LEGEND"
            )

        case "LEGEND_COLUMNS":
            parser.add_argument(
                "-lc",
                help="Number of legend columns",
                dest="LEGEND_COLUMNS",
                type=int,
                default=ARGS["LEGEND_COLUMNS"],
            )

        case "START_RADIUS":
            parser.add_argument(
                "-r",
                help="Initial radius of the circle",
                dest="START_RADIUS",
                type=float,
                default=ARGS["START_RADIUS"],
            )

        case "IMAGE_SIDE":
            parser.add_argument(
                "-h",
                help="Image side size (width and height)",
                dest="IMAGE_SIDE",
                type=int_or_str,
                default=ARGS["IMAGE_SIDE"],
            )

        case "IMAGE_SCALE":
            parser.add_argument(
                "-x",
                help="Image size multiplier",
                dest="IMAGE_SCALE",
                type=int,
                default=ARGS["IMAGE_SCALE"],
            )

        case "PLOT_WIDTH":
            parser.add_argument(
                "-w",
                help="Plot width",
                dest="PLOT_WIDTH",
                type=float,
                default=ARGS["PLOT_WIDTH"],
            )

        case "PLOT_HEIGHT":
            parser.add_argument(
                "-h",
                help="Plot height",
                dest="PLOT_HEIGHT",
                type=float,
                default=ARGS["PLOT_HEIGHT"],
            )

def setup(script_name):
    settings = tomllib.load(open("settings.toml", "rb"))

    # Get settings
    ACTIVITIES = settings["activities"]
    ARGS = settings["global"] | settings[script_name]

    # Parse arguments
    parser = argparse.ArgumentParser(add_help=False)
    add_argument("help", parser, ARGS)

    for argument in ARGS:
        add_argument(argument, parser, ARGS)

    parsed_args = dict(parser.parse_args()._get_kwargs())
    for arg in parsed_args:
        ARGS[arg] = parsed_args[arg]

    # Setup auto settings    
    if "UTC_OFFSET" in ARGS and ARGS["UTC_OFFSET"] == "auto":
        ARGS["UTC_OFFSET"] = -timezone

    return ARGS, ACTIVITIES
# Time
s = 1
m = 60 * s
h = 60 * m
d = 24 * h
w = 7 * d

# Colors
white = "\033[0m"
red = "\033[31m"
green = "\033[32m"
yellow = "\033[33m"
blue = "\033[34m"
magenta = "\033[35m"
cyan = "\033[36m"

# Days
weekdays = (
    "Пн",
    "Вт",
    "Ср",
    "Чт",
    "Пт",
    "Сб",
    "Вс"
)

months = (
    "Января",
    "Февраля",
    "Марта",
    "Апреля",
    "Мая",
    "Июня",
    "Июля",
    "Августа",
    "Сентября",
    "Октября",
    "Ноября",
    "Декабря"
)

def color(text, color):
    return f"{color}{text}{white}"

def normalize_color(activity):
    color = tuple([rgb/255 for rgb in activity])
    
    return color

def generate_activites_times(activities, timestamp):
    save_activities_names = set([i[0] for i in activities])
    activities_times = {activity_name: [] for activity_name in save_activities_names}

    for i, activity in enumerate(activities):
        pivot = activities[i+1][1] if i < len(activities) - 1 else timestamp
        activity_time = pivot - activity[1]
        
        # print(timedelta(activity_time))
        activities_times[activity[0]].append(activity_time)
        
    return activities_times

def stages_formatter(stages, verb=0):
    if verb:
        form = ["этапа", "этапов", "этапов"]
    else:
        form = ["этап", "этапа", "этапов"]
        
    last_digit = int(str(stages)[-1])
    last_2_digits = int(str(stages)[-2:])

    if last_digit == 1 and last_2_digits != 11:
        return f"{stages} {form[0]}"
    
    if 1 <= last_digit <= 4 and (last_2_digits < 10 or last_2_digits > 20):
        return f"{stages} {form[1]}"
    
    return f"{stages} {form[2]}"

# def delta(time, cap=d):    
#     for postfix, name in ((w, 'н'), (d, 'д'), (h, 'ч'), (m, 'м'), (s, 'с')):
#         if time >= postfix and postfix <= cap:
#             time = time / postfix
#             return f"{round(time) if round(time, 1) == round(time) else round(time, 1)}{name}"

def timedelta(time):
    time = int(time)
    
    if time < d:
        weeks = ""
    else:
        weeks = f"{time // d}д"
        time -= d * (time // d)
    
        if time == 0:
            return weeks
        else:
            weeks += " "
    
    clock = []
    for period in (h, m, s):
        clock.append(f"{time // period:02}")
        time -= period * (time // period)
    
    return weeks + ':'.join(clock)
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.ticker import PercentFormatter, MultipleLocator

import save
from setup import setup

from utils import w
from utils import normalize_color
from utils import generate_activites_times

ARGS, ACTIVITIES = setup("density")
activities_times = generate_activites_times(save.activities, save.timestamp)

bars = {}
period_times = {activity_name: 0 for activity_name in ACTIVITIES}

# Create plot canvas
fig, axs = plt.subplot_mosaic(
    [["average"]],
    figsize=(ARGS["PLOT_WIDTH"], ARGS["PLOT_HEIGHT"])
)

fig.canvas.manager.set_window_title("Плотность занятий")
ax = list(axs.items())

def construct_bars(week):
    offset = 0
    bars[week] = {}
    
    # Create bars for each activity
    for activity_name in period_times:
        percentage = period_times[activity_name] / period
        bars[week][activity_name] = percentage
        
        if activity_name == ARGS["VOID"] or percentage == 0: 
            continue
        
        ax[0][1].bar(
            x=week,
            height=percentage,
            bottom=offset,
            width=1,
            edgecolor="black",
            color=normalize_color(ACTIVITIES[activity_name]),
            linewidth=.5
        )

        if period_times[activity_name] >= ARGS["LABEL_TRESHOLD"] * period:
            ax[0][1].text(
                x=week,
                y=period_times[activity_name]/period/2 + offset,
                s=f"{round(period_times[activity_name]/period * 100, 1)}%",
                va="center",
                ha="center",
                rotation="vertical",
                clip_on=True
            )

        offset += percentage

# Process all activities and add them to plot
stage = 1
period = w * (stage if ARGS["CUMULATIVE"] else 1)

for i in range(len(save.activities)):
    activity = save.activities[i]
    
    total_time = sum([period_times[theme] for theme in period_times])
    this_activity_time = activities_times[activity[0]].pop(0)
    
    while total_time + this_activity_time >= period:
        period_times[activity[0]] += period - total_time
        this_activity_time -= period - total_time
        
        construct_bars(stage)

        if not ARGS["CUMULATIVE"]:
            for activity_name in period_times:
                period_times[activity_name] = 0
        
        stage += 1
        period = w * (stage if ARGS["CUMULATIVE"] else 1)
        total_time = sum([period_times[theme] for theme in period_times])
        
    else:
        period_times[activity[0]] += this_activity_time

else:
    # Create data for last not full week
    if (total_time + this_activity_time) % w != 0:
        construct_bars(stage)
        stage += 1

# Form legend
if ARGS["SHOW_LEGEND"]:
    legend_elements = []
    
    for activity_name in ACTIVITIES:
        if activity_name in activities_times and activity_name != ARGS["VOID"]:
            legend_elements.append(
                Patch(
                    facecolor=normalize_color(ACTIVITIES[activity_name]),
                    edgecolor="black",
                    linewidth=.5,
                    label=activity_name
                )
            )
    
    ax[0][1].legend(handles=legend_elements, ncol=ARGS["LEGEND_COLUMNS"])

def format_coord(x, y):
    # Form bar info
    bar_info = ""
    if 0.5 <= round(x) <= len(bars):
        percentage = 0
        for activity_name in bars[round(x)]:
            activity_percentage = bars[round(x)][activity_name]
            
            if percentage <= y <= percentage + activity_percentage:
                bar_info = (
                    f"{activity_name} "
                    f"({round(activity_percentage * 100, 1)}%, "
                    f"{round(activity_percentage * 7*24, 1)}ч/н, "
                    f"{round(activity_percentage * 24, 1)}ч/д)\n"
                )
                break
            
            percentage += bars[round(x)][activity_name]
    
    # Form position info
    position_info = (
        f"x={round(x)} неделя, "
        f"y={round(y * 100, 1)}% "
        f"({round(y * 24*7, 1)}ч/н, "
        f"{round(y * 24, 1)}ч/д)"
    )
    
    return bar_info + position_info

percentages_max = round(
    max(
        [sum(bars[i].values()) - (bars[i][ARGS["VOID"]] if ARGS["HIDE_VOID"] else 0)
        for i in range(1, stage)]
    ),
    1 + 2
)

ax[0][1].format_coord = format_coord

ax[0][1].set_xticks([i for i in range(1, stage)], [i for i in range(1, stage)])
ax[0][1].set_xlim(.5, stage - .5)

ax[0][1].set_ylim(0, percentages_max)
ax[0][1].yaxis.set_major_formatter(PercentFormatter(1.0))
ax[0][1].yaxis.set_major_locator(MultipleLocator(percentages_max / 10))

plt.tight_layout()

if ARGS["IMAGE"]:
    plt.savefig(f"density.png", bbox_inches="tight")

if not ARGS["SILENT"]:
    plt.show()
from math import ceil
from datetime import datetime

import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.ticker import PercentFormatter, MultipleLocator

import save
from setup import setup

from utils import m, h, d, w
from utils import generate_activites_times
from utils import normalize_color
from utils import weekdays, months

ARGS, ACTIVITIES = setup("bar")
activities_times = generate_activites_times(save.activities, save.timestamp)

save_activities = set([i[0] for i in save.activities])
average_day = {
    activity_name: sum(activities_times[activity_name])
    for activity_name in ACTIVITIES
    if activity_name in save_activities
}

# Create plot canvas
fig, axs = plt.subplot_mosaic(
    [["main", "average"]],
    figsize=(ARGS["PLOT_WIDTH"], ARGS["PLOT_HEIGHT"]),
    gridspec_kw={"width_ratios": (14, 1)}
)

fig.canvas.manager.set_window_title("Распределение времени")
ax = list(axs.items())

# First plot - bars for each days
def bar_constructor(x, y):
    global offset

    if activity[0] != ARGS["VOID"]:
        ax[0][1].bar(
            x=x,
            bottom=offset,
            width=1,
            height=y,
            edgecolor="black",
            linewidth=.5,
            color=normalize_color(ACTIVITIES[activity[0]])
        )
        
        if y >= d * ARGS["LABEL_TRESHOLD"]:
            ax[0][1].text(
                x=x,
                y=y/2 + offset,
                s=f"{round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)}ч",
                va="center",
                ha="center",
                clip_on=True
            )

    offset += y

# Generate all parts and add it to plot
experiment_start_time = save.activities[0][1]
all_experiment_time = save.timestamp - experiment_start_time

offset = (experiment_start_time + ARGS["UTC_OFFSET"]) % d
days = 1

for activity in save.activities:
    # Create one bar
    if activities_times[activity[0]][0] <= d - offset:
        bar_constructor(days, activities_times[activity[0]][0])

    else:
        to_distribute = activities_times[activity[0]][0]
        to_distribute -= d - offset
        bar_constructor(days, d - offset)

        # Create bars, separated by days
        while to_distribute != 0:
            days += 1
            offset = 0

            if to_distribute >= d:
                bar_constructor(days, d)
                to_distribute -= d
            else:
                bar_constructor(days, to_distribute)
                to_distribute = 0

    activities_times[activity[0]].pop(0)

if ARGS["SHOW_LEGEND"]:
    legend_elements = [
        Patch(
            facecolor=normalize_color(ACTIVITIES[i]),
            edgecolor="black",
            linewidth=.5,
            label=i
        ) for i in average_day if i != ARGS["VOID"]
    ]
    
    ax[0][1].legend(handles=legend_elements, ncol=ARGS["LEGEND_COLUMNS"], loc="lower left")

start_day = datetime.fromtimestamp(save.activities[0][1]).weekday()
start_hour = experiment_start_time % d + ARGS["UTC_OFFSET"]

if start_hour == d:
    start_hour = 0

def format_coord(x, y):
    x = int(x-.5)
    y = round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)
    
    selected_time = x*d + y*h + experiment_start_time - start_hour
    
    # Form bar info
    bar_info = ""
    for k, i in enumerate(save.activities):
        if i[1] >= selected_time or not save.activities[0][1] <= selected_time <= save.timestamp: break
        pivot = save.timestamp if len(save.activities)-1 == k else save.activities[k+1][1]
        
        bar_info = f"{i[0]}"
        bar_info += f" ({i[-1]})" if i[-1] else ""
        bar_info += (
            f" ({round((pivot - i[1]) / h, 1)}ч)\n" if (pivot - i[1]) / h >= 1 else
            f" ({round((pivot - i[1]) / m, 1)}м)\n"
        )
        
    # Form position info
    month = months[datetime.fromtimestamp(selected_time).month - 1]
    day = datetime.fromtimestamp(selected_time).day
    week = round((selected_time - experiment_start_time) // w + 1)
    
    position_info = (
        f"x={weekdays[(x+start_day)%7]}, {y=}ч "
        f"({day} {month}, {week} неделя)"
    )
        
    return bar_info + position_info

view_shift = ceil((all_experiment_time+start_hour) // d) - 13.5 if ceil((all_experiment_time) / w) > 2 else .5

ax[0][1].format_coord = format_coord

ax[0][1].set_xticks(range(1, days+1), [weekdays[(i+start_day)%7] for i in range(days)])
ax[0][1].set_xlim(view_shift, 15 + view_shift)
ax[0][1].xaxis.set_major_formatter(lambda x, _: weekdays[(int(x-.5)+start_day)%7])

ax[0][1].set_yticks(range(0, d+1, d//10), [f"{i}%" for i in range(0, 101, 10)])
ax[0][1].set_ylim(0, d)
ax[0][1].yaxis.set_major_formatter(lambda y, _: f"{round(y/h) if round(y/h, 1) == round(y/h) else round(y/h, 1)}ч")

# Second plot - average time
offset = 0

for activity in average_day:
    if activity != ARGS["VOID"]:
        ax[1][1].bar(
            x=1,
            bottom=offset,
            width=1,
            height=average_day[activity],
            edgecolor="black",
            color=normalize_color(ACTIVITIES[activity]),
            linewidth=.5
        )

        if average_day[activity] >= all_experiment_time * ARGS["AV_LABEL_TRESHOLD"]:
            ax[1][1].text(
                x=1,
                y=(average_day[activity]/2+offset),
                s=f"{round(average_day[activity]/all_experiment_time*100, 1)}%",
                va="center",
                ha="center",
                clip_on=True
            )

    offset += average_day[activity]

def format_coord(x, y):
    time_offset = 0
    
    # Form bar info
    bar_info = ""
    for activity in average_day:
        if time_offset + average_day[activity] > y:
            bar_info = f"{activity} ({round(average_day[activity]/all_experiment_time*100, 1)}%)\n"
            break
        
        time_offset += average_day[activity]
        
    # Form position info
    position_info = f"x=AV, y={round(y/all_experiment_time*100, 1)}%"
        
    return bar_info + position_info

average_time_max = all_experiment_time - (average_day[ARGS["VOID"]] if ARGS["HIDE_VOID"] else 0)

ax[1][1].format_coord = format_coord

ax[1][1].set_xticks((1,), ("AV",))
ax[1][1].set_xlim(.5, 1.5)
ax[1][1].xaxis.set_major_formatter(lambda *_: "AV")

ax[1][1].set_ylim(0, average_time_max)
ax[1][1].yaxis.set_major_formatter(PercentFormatter(all_experiment_time))
ax[1][1].yaxis.set_major_locator(MultipleLocator(average_time_max / 10))
ax[1][1].yaxis.tick_right()

plt.tight_layout()

if ARGS["IMAGE"]:
    plt.savefig(f"bar.png", bbox_inches="tight")

if not ARGS["SILENT"]:
    plt.show()
from datetime import datetime
from time import mktime

# formats:
# data: 26.07.2023 12:48:19
# unix-time: 1690364899.123

timestamp = input("Введите unix-time метку или дату: ")

if timestamp.count(':'):
    # data -> unix-time
    print("Unix-time метка:", mktime(datetime.strptime(timestamp, "%d.%m.%Y %H:%M:%S").timetuple()))
else:
    # unix-time -> data
    print("Дата:", datetime.fromtimestamp(float(timestamp)).strftime("%d.%m.%Y %H:%M:%S"))
from time import time
from re import sub, findall, fullmatch
from datetime import datetime, timedelta
from os import system, makedirs, path, name as os_name

from setup import setup

from utils import s, m, h, d, w
from utils import cyan, magenta, green, red, white
from utils import generate_activites_times

saved = True
timestamp = time()
activities = []

open("save.py", "a")  # Touch save file
from save import *

ARGS, ACTIVITIES = setup("tracker")
weeks = (timestamp - activities[0][1]) // (7*24*h) if activities else 0

def data_save(saved=True):
    if len(activities) == 0: return

    file = open("save.py", "w", encoding="utf-8")

    file.write(f"{saved = }\n{timestamp = }\nactivities = [ \n")
    for i in activities: file.write(f"\t{i},\n")
    file.write("]\n")

    file.close()

    # Weekly dump
    global weeks
    if saved and (timestamp - activities[0][1]) // (7*24*h) > weeks:
        weeks += 1

        filename = f"./dumps/week-{round(weeks)} ({activities[-1][2][:10]}).py"
        makedirs(path.dirname(filename), exist_ok=True)

        file = open(filename, "w", encoding="utf-8")

        file.write(f"{saved = }\ntimestamp = {activities[0][1] + weeks * 7*24*h}\nactivities = [ \n")
        for i in activities: file.write(f"\t{i},\n")
        file.write("]\n")

        file.close()

def stages_formatter(stages, verb=0):
    if verb:
        form = ["этапа", "этапов", "этапов"]
    else:
        form = ["этап", "этапа", "этапов"]
        
    last_digit = int(str(stages)[-1])
    last_2_digits = int(str(stages)[-2:])

    if last_digit == 1 and last_2_digits != 11: 
        return f"{magenta}{stages}{white} {form[0]}"
    
    if 1 <= last_digit <= 4 and (last_2_digits < 10 or last_2_digits > 20):
        return f"{magenta}{stages}{white} {form[1]}"
    
    return f"{magenta}{stages}{white} {form[2]}"

def analytics():
    if len(activities) == 0: return

    sum_all = timestamp - activities[0][1]
    print(
        f"Итоги {stages_formatter(len(activities), 1)} "
        f"({cyan}{timedelta(0, round(sum_all))}{white})"
    )

    activities_times = generate_activites_times(activities, timestamp)
    save_activities = set([i[0] for i in activities])

    # Analyze all data
    for activity_name in ACTIVITIES:
        if activity_name not in save_activities: continue
        
        activity_time = sum(activities_times[activity_name])
        if activity_time == 0: continue

        activity_percentage = activity_time/sum_all * 100
        activity_counter = len(activities_times[activity_name])
        activity_mean = activity_time / activity_counter

        print(
            f"{activity_name} ({stages_formatter(activity_counter)}) ({round(activity_percentage, 2)}%)\n"
            f"Всего: {cyan}{timedelta(0, round(activity_time))}{white}\n"
            f"В среднем {cyan}{timedelta(0, round(activity_mean))}{white} за этап\n"
        )

# Error cheking
if not saved:
    input(f"Последняя сессия была прервана: {activities[-1][0]} ({activities[-1][2]})")
    input(f"Добавление потерянного времени: {cyan}+{timedelta(0, int(time() - timestamp))}{white}\n")
    
    timestamp = time()
    data_save()

while True:
    system("cls" if os_name == "nt" else "clear")

    # Header
    activity = len(activities)
    stageline = "Последния сессия будет отображаться тут\n"
    
    if len(activities): 
        stageline = (
            f"Этап {magenta}{activity}{white}, {activities[-1][0]} "
            f"({datetime.fromtimestamp(timestamp).strftime('%H:%M:%S')}) "
            f"({cyan}{timedelta(0, round(timestamp - activities[-1][1]))}{white})\n"
        )

    print(stageline)

    # Activities
    print("Выбор занятия:")
    for i, name in enumerate(ACTIVITIES):
        print(f"{green}{i+1}{white}: {name}")
    
    print()

    for i, name in enumerate([
        "Завершить сессию", 
        "Удалить последнее занятие", 
        "Изменить время последнего занятия", 
        "Добавить подпись к последнему занятию"
    ]):
        print(f"{green}{'edci'[i]}{white}: {name}")
    
    # Gain input
    info = input("\nВвод: ").split()
    session_id = info[0] if info else ''
    
    force_new = False
    note = ''
    if len(info) > 1:
        if info[1] in ("-f", "-force"):
            force_new = True
            info.pop(1)

        note = ' '.join(info[1:])

    if session_id.isdigit():
        session_id = int(session_id)

    elif session_id in ('e', 'd', 'c', 'i'):
        session_id = len(ACTIVITIES) + "edci".index(session_id) + 1

    else:
        session_id = 0

    print()

    # Create new session
    if 1 <= session_id <= len(ACTIVITIES):
        activity_name = list(ACTIVITIES.keys())[session_id-1]

        # If activity repeat
        if len(activities) and activity_name == activities[-1][0] and not force_new:
            print(f"Продолжение предыдущей сессии -> {activities[-1][0]} ({activities[-1][2]})")

            # Bind new note if provided
            if note:
                activities[-1][3] = note

            note = activities[-1][3]

        else:
            if activity_name == ARGS["ANOTHER"]:
                if note == '':
                    note = input("Подпись: ") or (ARGS["ANOTHER_DEFAULT_NOTE"])

            activities.append([
                f"{activity_name}", 
                timestamp,
                f"{datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M:%S')}",
                note
            ])
        
        # Wait for input to end session
        data_save(saved=False)
        input(f"<< {activity_name}{'' if not note else ' (' + note + ')'} >>")
        
        timestamp = time()
    
    # End sesstion
    if session_id == len(ACTIVITIES) + 1:
        data_save()
        analytics()
        exit()

    # Delete last activity
    if session_id == len(ACTIVITIES) + 2 and len(activities):
        print(f"Удалить: {activities[-1][0]} ({activities[-1][2]})?")
        if input("y/n: ").lower() == "y":
            activities.pop()
        else:
            input(f"\n{red}Удаление отменено{white}")

    # Change last activity time
    if session_id == len(ACTIVITIES) + 3:
        activity_name = activities[-1][0]
        activity_start_time = activities[-1][2]

        activity_lasts = timedelta(0, round(timestamp - activities[-1][1]))
        print(f"Последний этап: {activity_name} ({activity_start_time}) {cyan}{activity_lasts}{white}")
        
        input_offset = input("Этап закончился раньше на: ").strip()

        # Validate string
        if fullmatch(r"^((([-+]?(\d+)?(\.\d*)?))?([smhdw])?(\s|$))+", input_offset):
            input_offset = sub(r"([-+]?\d+)(\s|$)", r"\1s ", input_offset)  # Translate values without type to seconds (1 -> 1s)
            input_offset = sub(r"(^|\s)((-?\+?)([smhdw]))", r" \g<3>1\4 ", input_offset)  # Add values to lone types (h -> 1h)
            input_offset = [(r[0], r[-1]) for r in findall(r"((-?|\+?)\d+(\.\d*)?)([smhdw])", input_offset)]  # Make (value, type) pairs

            offset = 0
            for pair in input_offset:
                offset += float(pair[0]) * {'s': s, 'm': m, 'h': h, 'd': d, 'w': w}[pair[1]]

            if offset < activity_lasts.total_seconds():
                timestamp -= offset
                activity_lasts = timedelta(0, round(timestamp - activities[-1][1]))
                input(f"\nНовая продолжительность этапа: {cyan}{activity_lasts}{white}")
            else:
                input(f"\n{red}Этап становится отрицательным, действие отменено{white}")
        else:
            input(f"\n{red}Недопустимая строка, действие отменено{white}")
        
    # Add a note
    if session_id == len(ACTIVITIES) + 4:
        activity_name = activities[-1][0]
        activity_start_time = activities[-1][2]
        activity_lasts = timedelta(0, round(timestamp - activities[-1][1]))

        print(f"Добавление подписи к предыдущему занятию\n{activity_name} ({activity_start_time}) {cyan}{activity_lasts}{white}")
        note = input("\nПодпись: ")

        activities[-1][-1] = note

    data_save()
import argparse

import random
import time
import re

from aliases import (
    glyph_sets,
    colors,
    color_sets,
    zombatar_colors,
    tilesets
)

# The argtypes do not resolve random values
# because this can break random number generator seed.
# So, all random values resolves in utils
# or in scripts directly.


def show_zombatar_colors(colorset):
    print(f'List of available zombatars {colorset} colors:')
    for i, color, in enumerate(zombatar_colors[colorset]):
        print(' ', i, color)


def show_bright_colors():
    show_zombatar_colors('bright')


def show_common_colors():
    show_zombatar_colors('common')


def show_skin_colors():
    show_zombatar_colors('skin')


def show_glyphsets():
    print('List of available glyphset aliases:')
    for glyphset in glyph_sets:
        print(' ', glyphset)


def show_colors():
    print('List of available colors:')
    for color, value in colors.items():
        print(' ', color, value)


def show_colorsets():
    print('List of available colorsets:')
    for colorset, values in color_sets.items():
        print(' ', colorset)


def glyphset(value):
    if value in glyph_sets:
        return glyph_sets[value]

    return value


def colorset(value):
    if isinstance(value, str):
        value = [value]

    # Resolve colorsets or single colors
    colors = []

    for c in value:
        if c in color_sets:
            colors.extend(color_sets[c])
        else:
            colors.append(color(c))

    return colors


def color(value):
    # The :color format
    if value in colors:
        return colors[value]

    # Comma separated color format
    elif re.match(r'(?:\d{1,3},){2}\d{1,3}', value):
        return tuple(
            int(c) for c in value.split(',')
        )

    # Hex color format
    elif re.match(r'#(?:[0-9A-Fa-f]{3}){1,2}', value):
        value = value[1:]  # Remove # sign

        if len(value) == 3:  # Parse #rgb type color
            value = tuple(
                int(c * 2, 16) for c in value
            )

        elif len(value) == 6:  # Parse #rrggbb type color
            value = tuple(
                int(c, 16) for c in (
                    value[:2], value[2:4], value[-2:]
            ))

        return value

    raise argparse.ArgumentTypeError(
        f'Color {value} not found'
    )


def seed(value):
    if value == ':random':
        value = hex(int(time.time() * 10e6))[2:]

    random.seed(value)
    return value


def dimension(value: str):
    value = int(value)

    if not value > 0:
        raise argparse.ArgumentTypeError(
            'Image dimensions must be greater than 0'
        )

    return value


def none_or_int(value: str):
    if value.isnumeric():
        return int(value)

    elif value == ':random':
        return None

    raise argparse.ArgumentTypeError(
        'Value must be a number or :random'
    )


def effects(value):
    if value == '0':
        return ''
    
    elif re.match(r"[1-6]+", value):
        return value[:6]

    elif value == ':random':
        return None
    
    raise argparse.ArgumentTypeError(
        'Value must be numeric string of 1-6 numbers, 0 or :random'
    )


def zombatar_color(value: str, colors):
    if value == ':random':
        return None

    elif value in colors:
        return colors[value]
    
    elif value.isnumeric():
        value = min(max(0, int(value)), len(colors) - 1)
        return tuple(colors.values())[value]

    else:
        raise argparse.ArgumentTypeError(
            f'Color {value} not found'
        )


def zombatar_bright_color(value: str):
    return zombatar_color(value, zombatar_colors['bright'])


def zombatar_common_color(value: str):
    return zombatar_color(value, zombatar_colors['common'])


def zombatar_skin_color(value: str):
    return zombatar_color(value, zombatar_colors['skin'])


def tileset(value: str):
    if value in tilesets:
        return tilesets[value]

    return value


def coprime(value: str):
    if value == ':random':
        return None
    
    elif value.isnumeric():
        return int(value)
    
    raise argparse.ArgumentTypeError(
        f'Value {value} can be threated as int or :random'
    )
import numpy as np
from PIL import (
    Image,
    ImageDraw
)

from math import ceil
from random import choice

from setup import setup
from utils import (
    resize,
    show_and_save
)

ARGS = setup('puzzles')
s = ARGS['tile_side']

if ARGS['by'] == 'tiles':
    ARGS['image_width'] *= (s + 1)
    ARGS['image_width'] += 1

    ARGS['image_height'] *= (s + 1)
    ARGS['image_height'] += 1

# Create canvas
data = np.full(
    (ARGS['image_height'], ARGS['image_width'], 3),
    tuple(255 - c for c in ARGS['line_color']),
    np.uint8
)

# Image border
data[0] = ARGS['line_color']
data[-1] = ARGS['line_color']

data[:, 0] = ARGS['line_color']
data[:, -1] = ARGS['line_color']

# Ledges
l = ARGS['ledge_length']
d = ARGS['ledge_depth']
v = ceil((s - l) / 2)  # Length of baseline parts

for y in range(0, ARGS['image_height'] - 1, s + 1):    
    for x in range(0, ARGS['image_width'] - 1, s + 1):
        if y != 0 and y != ARGS['image_height'] - 1:
            # _    _ of  _|‾‾|_
            data[y, x:x+v + 1] = ARGS['line_color']
            data[y, x+v+1+l:x+s+1] = ARGS['line_color']

            #   ‾‾   of  _|‾‾|_
            dy = choice((-1, 1))
            data[y+dy*d, x+v+1:x+v+1+l] = ARGS['line_color']

            #  |  |  of  _|‾‾|_
            data[y:y+dy*d+dy:dy, x+v] = ARGS['line_color']
            data[y:y+dy*d+dy:dy, x+v+1+l] = ARGS['line_color']

        # Same things but on y axis
        if x != 0 and x != ARGS['image_width'] - 1:
            data[y:y+v + 1, x] = ARGS['line_color']
            data[y+v+1+l:y+s+1, x] = ARGS['line_color']
            
            dx = choice((-1, 1))
            data[y+v+1:y+v+1+l, x+dx*d] = ARGS['line_color']

            data[y+v, x:x+dx*d+dx:dx] = ARGS['line_color']
            data[y+v+1+l, x:x+dx*d+dx:dx] = ARGS['line_color']

# Paint
image = Image.fromarray(data)

for y in range(0, ARGS['image_height'] - 1, s + 1):    
    for x in range(0, ARGS['image_width'] - 1, s + 1):
        ImageDraw.floodfill(image, (x+1, y+1), choice(ARGS['colorset']))

image = resize(
    image,
    ARGS['image_width'] * ARGS['image_scale_factor'],
    ARGS['image_height'] * ARGS['image_scale_factor'],
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
from PIL import (
    Image,
    ImageDraw
)

from math import floor
from random import (
    randint,
    sample
)

from setup import setup
from utils import (
    resize,
    show_and_save,
    limit
)

ARGS = setup('enemies')

image = Image.open('img/enemies/card.png').convert('RGBA')
draw = ImageDraw.Draw(image)

faces = Image.open('img/enemies/faces.png').convert('RGBA')
numbers = Image.open('img/enemies/numbers.png').convert('RGBA')
effects = Image.open('img/enemies/effects.png').convert('RGBA')

face = (limit(ARGS['face'], 1, 31) - 1) * 16
face = faces.crop((face, 0, face + 16, 16))
image.paste(face, (0, 0), face)

# Hp bar
max_hp = limit(ARGS["max_hp"], 1, 999)
hp = limit(ARGS["hp"], 1, max_hp)

# Red background
draw.rectangle(
    (10, 2, 10 + floor(hp / max_hp * 35), 8),
    fill=(227, 81, 0)  # Red
)

# Hp value
x, y = 11, 3
hp_text = f'{hp}/{max_hp}'
for i in hp_text:
    glyph = (
        numbers.crop((int(i)*4, 0, int(i)*4 + 4, 5))
        if i != '/' else
        numbers.crop((40, 0, 44, 5))
    )
    image.paste(glyph, (x, y), glyph)
    x += 4

# Mana bar
max_mana = limit(ARGS["max_mana"], 1, 999)
mana = limit(ARGS["mana"], 0, max_mana)

# Blue background
if mana != 0:
    draw.rectangle(
        (10, 10, 10 + floor(mana / max_mana * 35), 16),
        fill=(97, 162, 255)  # Blue
    )

# Mana value
x, y = 11, 11
mana_text = f'{mana}/{max_mana}'
for i in mana_text:
    glyph = (
        numbers.crop((int(i)*4, 0, int(i)*4 + 4, 5))
        if i != '/' else 
        numbers.crop((40, 0, 44, 5))
    )
    image.paste(glyph, (x, y), glyph)
    x += 4

# Level
x, y = 1, 11
level_text = str(limit(ARGS['level'], 1, 99))

if len(level_text) == 1:
    x += 2

for i in level_text:
    glyph = numbers.crop((int(i)*4, 0, int(i)*4 + 4, 5))
    image.paste(glyph, (x, y), glyph)
    x += 4

# Additional effects
x, y = 10, 18
effects_str = ARGS['effects'] if ARGS['effects'] is not None else (
    sample(list('123456'), randint(0, 6))
)

# Display icons of effects
for i in effects_str:
    glyph = effects.crop((int(i)*4 - 4, 0, int(i)*4, 4))
    image.paste(glyph, (x, y), glyph)
    x += 5

image = resize(
    image,
    48 * ARGS['image_scale_factor'],
    24 * ARGS['image_scale_factor']
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
import numpy as np
from PIL import Image

from math import gcd
from random import randint

from setup import setup
from aliases import figures
from utils import (
    resize,
    show_and_save
)

# Original idea gathered from Foo52
# https://www.youtube.com/watch?v=IdwR58QmCo8

ARGS = setup('coprimes')
l = ARGS['line_length']

width = ARGS['image_width']
height = ARGS['image_height']

if width and height and gcd(width, height) != 1:
    print("Can't generate image: width and height isn't coprime numbers")
    exit()


def get_coprimes(iw=None, ih=None):
    while True:
        width = randint(10, 100) if iw is None else iw
        height = randint(10, 100) if ih is None else ih

        if gcd(width, height) == 1:
            return width, height


# Check if one dimension is already selected
if width is None and height is not None:
    width, height = get_coprimes(width, height)

elif width is not None and height is None:
    width, height = get_coprimes(width, height)

elif width is None and height is None:
    width, height = get_coprimes()

if ARGS['show_seed']:
    print(f"Seed: {ARGS['seed']}, width: {width}, height: {height}")

# Create canvas
data = np.full(
    (height * l, width * l, 3),
    ARGS['background_color_a'],
    np.uint8
)

x, y = 0, 0
x_vel, y_vel = 1, 1

step = 0
bounces = 0


def draw_line(canvas, x, y, x_vel, y_vel):
    l = ARGS['line_length']
    t = ARGS['line_thickness']

    for i in range(l):
        canvas[y + i*y_vel][x + i*x_vel] = ARGS['line_color']

        for j in range(1, t):
            dx, dy = i * x_vel, i * y_vel
            directions = {
                1: j < l - i,
                -1: j <= i
            }

            for d in directions:
                if directions[y_vel * d]:
                    canvas[y + dy + j*d][x + dx] = ARGS['line_color']


# Create carpet
while bounces != 2:
    bounces = 0

    # Draw line or pixel
    if step % 2 == 0:
        draw_line(data, x, y, x_vel, y_vel)

    # Move on next tile
    x += x_vel * l
    y += y_vel * l

    # Bounce
    if not -1 < x < width * l:
        x -= x_vel
        x_vel = -x_vel
        bounces += 1

    if not -1 < y < height * l:
        y -= y_vel
        y_vel = -y_vel
        bounces += 1

    step += 1


def exclude_figure(figure):
    w, h, cells = figure.values()

    figure = np.full(
        (w * l, h * l, 3),
        ARGS['background_color_a'],
        np.uint8
    )

    # Generate figure
    for x, y, y_vel in cells:
        x, y = x*l, y*l

        if y_vel == -1:
            y += l - 1

        draw_line(figure, x, y, 1, y_vel)

    # Show sample
    # image = Image.fromarray(figure)
    # image.show()

    # Compare and remove figure samples in sliding window
    for y in range(height - (h-1)):
        for x in range(width - (w-1)):
            window = np.s_[y*l:(y+h)*l, x*l:(x+w)*l]

            if np.all(data[window] == figure):
                data[window] = ARGS['background_color_a']


for figure in ARGS['exclude']:
    exclude_figure(figures[figure])

# Paint
x, y = 0, 0

if ARGS['background_color_a'] != ARGS['background_color_b']:
    for y in range(height * l):
        color_a = ARGS['background_color_a']
        color_b = ARGS['background_color_b']

        if y % (4 * l) >= 2 * l:
            color_a, color_b = color_b, color_a 

        for x in range(width * l):
            on_baseline = any((
                (x % (2*l) == y % (2*l)),
                ((x+1) % (2*l) == -y % (2*l))
            ))

            if on_baseline and np.all(data[y][x] == ARGS['line_color']):
                color_a, color_b = color_b, color_a
            
            if not np.all(data[y][x] == ARGS['line_color']):
                data[y][x] = color_a

            # Show baseline
            # if on_baseline:
            #     data[y][x] = (255, 0,0)

image = Image.fromarray(data)
image = resize(
    image,
    width*l * ARGS['image_scale_factor'],
    height*l * ARGS['image_scale_factor'],
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
import numpy as np
from PIL import Image

from random import choice

from setup import setup
from utils import (
    resize,
    limit,
    show_and_save
)

ARGS = setup('mapper')
samples = 'img/tilesets'

# Load and split tileset
t = np.array(Image.open(ARGS['tileset']).convert('RGB'))
tile_width, tile_height, _ = np.array(t.shape) // 4
tile_padding = ARGS['tile_padding']

# Full tile width and height
cell_width = tile_width + tile_padding
cell_height = tile_height + tile_padding

tileset = tuple(  # Slice tileset to list
    t[x:x+tile_width, y:y+tile_height]
    for x in range(0, t.shape[0], tile_width)
    for y in range(0, t.shape[1], tile_height)
)

if ARGS['by'] == 'tiles':
    ARGS['image_width'] *= cell_width 
    ARGS['image_width'] += tile_padding

    ARGS['image_height'] *= cell_height
    ARGS['image_height'] += tile_padding

# Create canvas
data = np.full(
    (ARGS['image_height'], ARGS['image_width'], 3),
    ARGS['background_color'],
    np.uint8
)

def draw_cell(canvas, x, y, tile, color):
    mask = np.all(tile == (0, 0, 0), axis=-1)
    new_tile = np.full_like(tile, ARGS['background_color'])
    new_tile[~mask] = color  # Fill non zero values with selected color

    canvas[y:y+tile.shape[0], x:x+tile.shape[1]] = new_tile

# Debug: draw tileset by tiles
if ARGS['show_tiles']:
    x = y = tile_padding
    for tile in range(16):
        color = [255] * 3
        data[y, x] = (255, 0, 0)  # Mark center
        draw_cell(data, x, y, tileset[tile], color)

        if (tile + 1) % 4 == 0:  # Go on next line
            x -= (cell_width) * 3
            y += cell_height
        else:
            x += cell_width

# Process growth
processed = dict()  # (x, y): tile_index
to_process = [(  # (x, y) values
    (ARGS['image_width'] - tile_width) // 2,
    (ARGS['image_height'] - tile_height) // 2
)]

up    = 0b1000
down  = 0b0100
left  = 0b0010
right = 0b0001

# x_vel, y_vel, dir, -dir
directions = (
    (0, -1, up, down),
    (0, 1, down, up),
    (-1, 0, left, right),
    (1, 0, right, left)
)

while to_process:
    x, y = to_process.pop(0)
    available_tiles = [*range(1, 16)] if len(processed) else [15]

    # Check available growth directions
    for direction in directions:
        check_x = x + direction[0] * cell_width
        check_y = y + direction[1] * cell_height
        front = direction[2]
        backwards = direction[3]

        in_bounds = (
            0 <= check_x <= ARGS['image_width'] - cell_width and
            0 <= check_y <= ARGS['image_height'] - cell_height
        )

        if (check_x, check_y) in processed:
            if processed[(check_x, check_y)] & backwards:
                available_tiles = [
                    tile for tile in available_tiles
                    if tile & front
                ]
            else:
                available_tiles = [
                    tile for tile in available_tiles
                    if not tile & front
                ]

        # Limit generation
        elif (
            ARGS['tile_limit'] and len(processed) > ARGS['tile_limit']
            or not in_bounds
        ):
            available_tiles = [
                tile for tile in available_tiles
                if not tile & front
            ]

    # Draw selected tile
    tile = choice(available_tiles)
    processed[(x, y)] = tile

    # Create new outgrowths
    for direction in directions:

        check_x = x + direction[0] * cell_width
        check_y = y + direction[1] * cell_height
        new_pos = (check_x, check_y)

        if not direction[2] & tile:
            continue

        if not 0 <= check_x <= ARGS['image_width'] - cell_width \
        or not 0 <= check_y <= ARGS['image_height'] - cell_height:
            continue

        if new_pos not in processed and new_pos not in to_process:
            to_process.append(new_pos)

# Paint each cell in the end
for i, pos in enumerate(processed):
    x, y = pos
    tile = processed[pos]

    progress = i / len(processed)
    color = choice(ARGS['colorset'])

    match ARGS['color_style']:
        case ':pulse':
            color = [
                limit(int(c * (1 - progress)), 0, 255) for c in color
            ]

        case ':spot':
            value = int(len(ARGS['colorset']) * progress)
            color = ARGS['colorset'][
                limit(value, 0, len(ARGS['colorset']) - 1)
            ]

    draw_cell(data, x, y, tileset[tile], color)

image = Image.fromarray(data)
image = resize(
    image,
    ARGS['image_width'] * ARGS['image_scale_factor'],
    ARGS['image_height'] * ARGS['image_scale_factor']
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
import numpy as np
from PIL import Image

from random import (
    choice,
    randint
)

from setup import setup
from utils import (
    resize,
    show_and_save
)

ARGS = setup('worm')

# Create canvas
data = np.full(
    (ARGS['image_height'], ARGS['image_width'], 3),
    ARGS['background_color'],
    np.uint8
)

directions = []
cells = dict()  # (x, y): visits

if ARGS['move_straight']:
    directions.extend((
        (0, -1),  # Up
        (0, 1),   # Down
        (-1, 0),  # Left
        (1, 0),   # Right
    ))

if ARGS['move_diagonal']:
    directions.extend((
        (-1, -1),  # Up left
        (-1, 1),   # Up right
        (1, -1),   # Down left
        (1, 1),    # Down right
    ))

# Random walk
x, y = ARGS['image_width']//2, ARGS['image_height']//2
direction = choice(directions)

for i in range(ARGS['step_limit']):
    # Choice direction
    available_directions = directions.copy()
    if not ARGS['move_backwards']:  # Remove previous direction
        available_directions.remove(direction)
    direction = choice(available_directions)

    # Make steps in this direction
    for step in range(
        randint(ARGS['step_min_length'], ARGS['step_max_length'])
    ):
        x += direction[0]
        y += direction[1]

        if not 0 <= x <= ARGS['image_width'] - 1:
            x = abs(x - ARGS['image_width'] + 2)

        if not 0 <= y <= ARGS['image_height'] - 1:
            y = abs(y - ARGS['image_height'] + 2)
        
        cells.setdefault((x, y), 0)
        cells[(x, y)] += 1

# Paint
for i, cell in enumerate(cells):
    color = min(cells[cell], len(ARGS['colorset'])) - 1
    x, y = cell

    data[y][x] = ARGS['colorset'][color]

image = Image.fromarray(data)
image = resize(
    image,
    ARGS['image_width'] * ARGS['image_scale_factor'],
    ARGS['image_height'] * ARGS['image_scale_factor']
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
colors = {
    ':black': (0, 0, 0),
    ':white': (255, 255, 255),
    ':red': (255, 0, 0),
    ':green': (0, 255, 0),
    ':blue': (0, 0, 255),
    ':pink': (255, 0, 255),
    ':cyan': (0, 255, 255),
    ':yellow': (255, 255, 0),

    ':c:black': (21, 23, 32),
    ':c:red': (255, 99, 132),
    ':c:orange': (255, 159, 64),
    ':c:yellow': (255, 205, 86),
    ':c:green': (75, 192, 192),
    ':c:blue': (54, 162, 235),
    ':c:purple': (153, 102, 255),
    ':c:grey': (201, 203, 207),

    ":p:black": (0, 0, 0),
    ":p:dark-blue": (29, 43, 83),
    ":p:dark-purple": (126, 37, 83),
    ":p:dark-green": (0, 135, 81),
    ":p:brown": (171, 82, 54),
    ":p:dark-grey": (95, 87, 79),
    ":p:light-grey": (194, 195, 199),
    ":p:white": (255, 241, 232),
    ":p:red": (255, 0, 77),
    ":p:orange": (255, 163, 0),
    ":p:yellow": (255, 236, 39),
    ":p:green": (0, 228, 54),
    ":p:blue": (41, 173, 255),
    ":p:lavender": (131, 118, 156),
    ":p:pink": (255, 119, 168),
    ":p:light-peach": (255, 204, 170),
}

color_sets = {
    ':casual': (
        tuple(
            colors[c] for c in colors
            if c.startswith(':c:') and c != ':c:black'
        )
    ),
    ':pico-8': (
        tuple(
            colors[c] for c in colors
            if c.startswith(':p:') and c != ':p:black'
        )
    ),
    ':base': (
        tuple(colors[c] for c in colors if c.count(':') == 1)
    ),
    ':grayscale': (
        tuple((c, c, c) for c in range(255, 0, -32))
    ),
    ':redscale': (
        tuple((c, 0, 0) for c in range(255, 0, -32))
    ),
    ':greenscale': (
        tuple((0, c, 0) for c in range(255, 0, -32))
    ),
    ':bluescale': (
        tuple((0, 0, c) for c in range(255, 0, -32))
    ),
    ':pinkscale': (
        tuple((c, 0, c) for c in range(255, 0, -32))
    ),
    ':cyanscale': (
        tuple((0, c, c) for c in range(255, 0, -32))
    ),
    ':yellowscale': (
        tuple((c, c, 0) for c in range(255, 0, -32))
    ),
}

glyph_sets = {
    ':all': (
        '!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKL'
        'MNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxy'
        'z{|}~⌂ ¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆ'
        'ÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòó'
        'ôõö÷øùúûüýþÿĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠ'
        'ġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌō'
        'ŎŏŐőŒœŔŕŖŗŘřŚśŜŝŞşŠšŢţŤťŦŧŨũŪūŬŭŮůŰűŲųŴŵŶŷŸŹź'
        'ŻżŽžſƒơƷǺǻǼǽǾǿȘșȚțɑɸˆˇˉ˘˙˚˛˜˝;΄΅Ά·ΈΉΊΌΎΏΐΑΒΓΔ'
        'ΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρς'
        'στυφχψωϊϋόύώϐϴЀЁЂЃЄЅІЇЈЉЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНО'
        'ПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъы'
        'ьэюяѐёђѓєѕіїјљњћќѝўџҐґ־אבגדהוזחטיךכלםמןנסעףפץ'
        'צקרשתװױײ׳״ᴛᴦᴨẀẁẂẃẄẅẟỲỳ‐‒–—―‗‘’‚‛“”„‟†‡•…‧‰′″‵'
        '‹›‼‾‿⁀⁄⁔⁴⁵⁶⁷⁸⁹⁺⁻ⁿ₁₂₃₄₅₆₇₈₉₊₋₣₤₧₪€℅ℓ№™Ω℮⅐⅑⅓⅔⅕⅖'
        '⅗⅘⅙⅚⅛⅜⅝⅞←↑→↓↔↕↨∂∅∆∈∏∑−∕∙√∞∟∩∫≈≠≡≤≥⊙⌀⌂⌐⌠⌡─│┌┐└'
        '┘├┤┬┴┼═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬▀▁▄█▌▐░▒▓■'
        '□▪▫▬▲►▼◄◊○●◘◙◦☺☻☼♀♂♠♣♥♦♪♫✓ﬁﬂ�╪╫'
    ),
    ':english': (
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        'abcdefghijklmnopqrstuvwxyz'
    ),
    ':russian': (
        'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'
        'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
    ),
    ':greek': (
        'ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψω'
    ),
    ':numbers': (
        '0123456789'
    ),
    ':borders': (
        '─│┌┐└┘├┤┬┴┼═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬'
    ),
    ':punctuation': (
        '{};\\/:|<>?/~`[]()*&^%$#@!'
    ),
    ':angles': (
        '┌┐└┘'
    ),
    ':c': (
        'ĆĈĊČC'
        'ćĉċčc'
    ),
}

zombatar_colors = {
    'bright': {
        ':white': (0, 0, 0),
        ':red': (358, 92, -8),
        ':pink': (312, 64, -4),
        ':bright-pink': (284, 21, -2),
        ':purple': (273, 77, -6),
        ':blue': (244, 69, -6),
        ':magenta': (209, 69, -6),
        ':light-cyan': (188, 20, -2),
        ':cyan': (179, 79, -8),
        ':green': (136, 92, -15),
        ':light-green': (90, 83, -26),
        ':dark-green': (136, 89, -44),
        ':yellow': (59, 83, -4),
        ':brown': (46, 91, -12),
        ':orange': (25, 90, -6),
        ':calamansi': (59, 29, -4),
        ':coffe': (37, 48, -28),
        ':dark-red': (358, 89, -39)
    },
    'common': {
        ':white': (0, 0, 0),
        ':dark-red': (0, 78, -42),
        ':red': (0, 73, -23),
        ':orange': (22, 78, -15),
        ':calamansi': (60, 31, -2),
        ':pale-yellow': (48, 64, -7),
        ':bright-coffe': (36, 60, -36),
        ':coffe': (32, 70, -59),
        ':brown': (26, 94, -73),
        ':dark': (207, 18, -77),
        ':black': (240, 100, -97),
        ':water': (180, 17, -7),
        ':blue': (224, 74, -6),
        ':mint': (163, 94, -22),
        ':foliage-green': (69, 90, -29),
        ':light-green': (131, 86, -19),
        ':pink': (298, 72, -11),
        ':purple': (270, 77, -21)
    },
    'skin': {
        ':skin-1': (91, 17, -43),
        ':skin-2': (136, 41, -48),
        ':skin-3': (71, 30, -48),
        ':skin-4': (67, 62, 50),
        ':skin-5': (67, 35, -37),
        ':skin-6': (83, 93, -42),
        ':skin-7': (101, 62, -45),
        ':skin-8': (83, 93, -42),
        ':skin-9': (100, 41, -35),
        ':skin-10': (125, 58, -40),
        ':skin-11': (125, 40, -31),
        ':skin-12': (92, 25, -53)
    }
}

tilesets = {
    ':cross': 'img/tilesets/cross.png',
    ':tiny': 'img/tilesets/tiny.png',
    ':square': 'img/tilesets/square.png',
    ':gallery': 'img/tilesets/gallery.png',
}

figures = {
    ':circle': {
        'width': 2,
        'height': 2,
        # Here you can make own figure samples
        # 'data': ((x, y, y_vel), (x, y, y_vel), ...)
        'data': (
            (0, 0, -1), (1, 0, 1),
            (0, 1, 1), (1, 1, -1)
        )
    },
    ':cross': {
        'width': 4,
        'height': 4,
        'data': (
            (0, 0, -1), (1, 0, 1), (2, 0, -1), (3, 0, 1),
            (0, 1, 1), (3, 1, -1), (0, 2, -1), (3, 2, 1),
            (0, 3, 1), (1, 3, -1), (2, 3, 1), (3, 3, -1)
        )
    },
}
import argparse
import tomllib

import argtypes
import aliases

# This setup file configures all parameters for argparse
# for all scripts. Default values stored in settings.toml,
# allaliases for values stored in groups.py 


def add_argument(argument, parser, ARGS, script_name):
    match argument:
        # Helper arguments
        case 'help':
            parser.add_argument(
            '-help', '--help',
            action='help',
            default=argparse.SUPPRESS,
            help='Show all script startup parameters and exit'
        )

        case 'show_glyphsets':
            parser.add_argument(
                '--show-glyphsets',
                help=(
                    'Show list of all available glyphs '
                    'aliases with values'
                ),
                action='store_true',
            )

        case 'show_colors':
            parser.add_argument(
                '--show-colors',
                help=(
                    'Show list of all available color '
                    'aliases with values'
                ),
                action='store_true',
            )

        case 'show_colorsets':
            parser.add_argument(
                '--show-colorsets',
                help=(
                    'Show list of all available colorsets '
                    'aliases with values'
                ),
                action='store_true',
            )

        case 'show_bright_colors':
            parser.add_argument(
                '--show-bright-colors',
                help=(
                    'Show list of all available bright '
                    'color aliases with values'
                ),
                action='store_true',
            )

        case 'show_common_colors':
            parser.add_argument(
                '--show-common-colors',
                help=(
                    'Show list of all available common '
                    'color aliases with values'
                ),
                action='store_true',
            )

        case 'show_skin_colors':
            parser.add_argument(
                '--show-skin-colors',
                help=(
                    'Show list of all available skin '
                    'color aliases with values'
                ),
                action='store_true',
            )

        # Global arguments
        case 'seed':
            parser.add_argument(
                '-s', '--seed',
                help=(
                    'Seed for random number generator. '
                    'Can be :random or any other string '
                    'to lock the seed'
                ),
                default=ARGS['seed'],
                type=argtypes.seed,
                dest='seed',
            )

        case 'show_seed':
            parser.add_argument(
                '-ss', '--show-seed',
                help='Display script current seed value',
                action='store_const',
                const=not ARGS['show_seed'],
                default=ARGS['show_seed'],
                dest='show_seed',
            )

        case 'quiet':
            parser.add_argument(
                '-q',
                help=(
                    'Do not show result image. Disabled if '
                    'no output image specified'
                ),
                action='store_const',
                const=not ARGS['quiet'],
                default=ARGS['quiet'],
                dest='quiet',
            )

        case 'output':
            parser.add_argument(
                '-o',
                help=(
                    'Output image, must be with image extension '
                    'such as .png, .jpeg, .bmp or other'
                ),
                default=ARGS['output'],
                type=str,
                dest='output',
            )

        # Glyphs
        case 'font_name':
            parser.add_argument(
                '-f', '-fn',
                help='Set up font by given name',
                default=ARGS['font_name'],
                type=str,
                dest='font_name',
            )

        case 'font_size':
            parser.add_argument(
                '-fs',
                help='Set up font size',
                default=ARGS['font_size'],
                type=int,
                dest='font_size',
            )

        case 'font_padding':
            parser.add_argument(
                '-p', '-fp', '-fm',
                help='Gap between glyphs on image',
                default=ARGS['font_padding'],
                type=int,
                dest='font_padding',
            )

        case 'font_aliasing':
            parser.add_argument(
                '-fa',
                help='Alias font on render',
                action='store_const',
                const=not ARGS['font_aliasing'],
                default=ARGS['font_aliasing'],
                dest='font_aliasing',
            )

        case 'glyphset':
            parser.add_argument(
                '-g',
                help='List of symbols that will make up the image',
                default=ARGS['glyphset'],
                type=argtypes.glyphset,
                dest='glyphset',
            )

        case 'glyph_colorset':
            parser.add_argument(
                '-gc',
                help=(
                    'List of colors for glyphs. '
                    'Can accept #rrggbb, #rgb, r,g,b or :alias values'
                ),
                default=ARGS['glyph_colorset'],
                type=str,
                dest='glyph_colorset',
                nargs='+'
            )

        case 'background_color' if script_name != 'zombatars':
            parser.add_argument(
                '-bg',
                help='Image background color',
                default=ARGS['background_color'],
                type=argtypes.color,
                dest='background_color',
            )

        case 'image_width' if script_name != 'coprimes':
            parser.add_argument(
                '-w',
                help=(
                    'Image width. Can be parametrized with -as '
                    'flag as pixels or tiles (if available)'
                ),
                default=ARGS['image_width'],
                type=argtypes.dimension,
                dest='image_width',
            )

        case 'image_height' if script_name != 'coprimes':
            parser.add_argument(
                '-h',
                help=(
                    'Image height. Can be parametrized with -as '
                    'flag as pixels or tiles (if available)'
                ),
                default=ARGS['image_height'],
                type=argtypes.dimension,
                dest='image_height',
            )

        case 'by':
            parser.add_argument(
                '-by',
                help='The size unit for image width and height',
                default=ARGS['by'],
                choices=('pixels', 'tiles'),
                dest='by',
            )

        case 'image_scale_factor':
            parser.add_argument(
                '-x',
                help='Final image scale multiplier',
                default=ARGS['image_scale_factor'],
                type=int,
                dest='image_scale_factor',
            )

        # Enemies
        case 'face':
            parser.add_argument(
                '-f',
                metavar='FACE: 1-31',
                help='Enemy face icon',
                default=ARGS['face'],
                type=argtypes.none_or_int,
                dest='face',
            )

        case 'level':
            parser.add_argument(
                '-l',
                metavar='LEVEL: 0-99',
                help='Enemy level',
                default=ARGS['level'],
                type=argtypes.none_or_int,
                dest='level',
            )

        case 'hp':
            parser.add_argument(
                '-hp',
                metavar='HP: 1-999',
                help='Enemy current hp',
                default=ARGS['hp'],
                type=argtypes.none_or_int,
                dest='hp',
            )

        case 'max_hp':
            parser.add_argument(
                '-mhp',
                metavar='MAX_HP: 1-909',
                help='Enemy max hp',
                default=ARGS['max_hp'],
                type=argtypes.none_or_int,
                dest='max_hp',
            )

        case 'mana':
            parser.add_argument(
                '-m',
                metavar='MANA: 0-999',
                help='Enemy current mana',
                default=ARGS['mana'],
                type=argtypes.none_or_int,
                dest='mana',
            )

        case 'max_mana':
            parser.add_argument(
                '-mm',
                metavar='MAX_MANA: 1-999',
                help='Enemy max mana',
                default=ARGS['max_mana'],
                type=argtypes.none_or_int,
                dest='max_mana',
            )

        case 'effects':
            parser.add_argument(
                '-e',
                metavar='EFFECTS: 1-6 | 0',
                help='String of enemy effects by indexes',
                default=ARGS['effects'],
                type=argtypes.effects,
                dest='effects',
            )

        # Zombatars
        case 'background':
            parser.add_argument(
                '-bg',
                metavar='BACKGROUND: 1-5',
                help='Type of image background',
                default=ARGS['background'],
                type=argtypes.none_or_int,
                dest='background',
            )

        case 'background_color':
            parser.add_argument(
                '-bgc',
                metavar='BACKGROUND_COLOR: 1-18 | BRIGHT_COLOR',
                help=(
                    'Background color index '
                    'for background of 1 type'
                ),
                default=ARGS['background_color'],
                type=argtypes.zombatar_bright_color,
                dest='background_color',
            )

        case 'skin_color':
            parser.add_argument(
                '-sc',
                metavar='SKIN_COLOR: 1-12 | SKIN_COLOR',
                help='Zombie skin color index',
                default=ARGS['skin_color'],
                type=argtypes.zombatar_skin_color,
                dest='skin_color',
            )

        case 'cloth':
            parser.add_argument(
                '-c',
                metavar='CLOTH: 0-12',
                help='Zombie cloth element',
                default=ARGS['cloth'],
                type=argtypes.none_or_int,
                dest='cloth',
            )

        case 'tidbit':
            parser.add_argument(
                '-t',
                metavar='TIDBIT: 0-14',
                help='Zombie tidbit element',
                default=ARGS['tidbit'],
                type=argtypes.none_or_int,
                dest='tidbit',
            )

        case 'tidbit_color':
            parser.add_argument(
                '-tc',
                metavar='TIDBIT_COLOR: 1-18 | BRIGHT_COLOR',
                help=(
                    'Color index of tidbit for '
                    '2, 3, 10, 11 and 12 type of them'
                ),
                default=ARGS['tidbit_color'],
                type=argtypes.zombatar_bright_color,
                dest='tidbit_color',
            )

        case 'accessory':
            parser.add_argument(
                '-a',
                metavar='ACCESSORY: 0-16',
                help='Zombie accessory element',
                default=ARGS['accessory'],
                type=argtypes.none_or_int,
                dest='accessory',
            )

        case 'accessory_color':
            parser.add_argument(
                '-ac',
                metavar='ACCESSORY_COLOR: 1-18 | BRIGHT_COLOR',
                help=(
                    'Color index of accessory for '
                    '9, 11, 13 and 14 types of them'
                ),
                default=ARGS['accessory_color'],
                type=argtypes.zombatar_bright_color,
                dest='accessory_color',
            )

        case 'mustache':
            parser.add_argument(
                '-m',
                metavar='MUSTACHE: 0-24',
                help='Zombie mustache element',
                default=ARGS['mustache'],
                type=argtypes.none_or_int,
                dest='mustache',
            )

        case 'mustache_color':
            parser.add_argument(
                '-mc',
                metavar='MUSTACHE_COLOR: 1-18 | COMMON_COLOR',
                help='Zombie mustache color index',
                default=ARGS['mustache_color'],
                type=argtypes.zombatar_common_color,
                dest='mustache_color',
            )

        case 'hair':
            parser.add_argument(
                '-h',
                metavar='HAIR: 0-16',
                help='Zombie hair element',
                default=ARGS['hair'],
                type=argtypes.none_or_int,
                dest='hair',
            )

        case 'hair_color':
            parser.add_argument(
                '-hc',
                metavar='HAIR_COLOR: 1-18 | COMMON_COLOR',
                help='Zombie hair color index',
                default=ARGS['hair_color'],
                type=argtypes.zombatar_common_color,
                dest='hair_color',
            )

        case 'eyewear':
            parser.add_argument(
                '-e',
                metavar='EYEWEAR: 0-16',
                help='Zombie eyewear element',
                default=ARGS['eyewear'],
                type=argtypes.none_or_int,
                dest='eyewear',
            )

        case 'eyewear_color':
            parser.add_argument(
                '-ec',
                metavar='EYEWEAR_COLOR: 1-18 | BRIGHT_COLOR',
                help=(
                    'Color index of eyewear which eyewear '
                    'type is less than 13'
                ),
                default=ARGS['eyewear_color'],
                type=argtypes.zombatar_bright_color,
                dest='eyewear_color',
            )

        case 'hat':
            parser.add_argument(
                '-hat',
                metavar='HAT: 0-14',
                help='Zombie hat element',
                default=ARGS['hat'],
                type=argtypes.none_or_int,
                dest='hat',
            )

        case 'hat_color':
            parser.add_argument(
                '-hatc',
                metavar='HAT_COLOR: 1-18 | BRIGHT_COLOR',
                help='Color index of hat if it\'s not 13 type',
                default=ARGS['hat_color'],
                type=argtypes.zombatar_bright_color,
                dest='hat_color',
            )

        # Mapper
        case 'show_tiles':
            parser.add_argument(
                '-d', '--show_tiles',
                help='Draw tileset in top left corner',
                action='store_const',
                const=not ARGS['show_tiles'],
                default=ARGS['show_tiles'],
                dest='show_tiles'
            )

        case 'tileset':
            parser.add_argument(
                '-t',
                help=(
                    'Tile view style. Can be '
                    'tile :alias or path to fileset file'
                ),
                default=ARGS['tileset'],
                type=argtypes.tileset,
                dest='tileset',
            )

        case 'tile_limit':
            parser.add_argument(
                '-l', '-tl', '-lim',
                help='Limit number of tiles to be generated',
                default=ARGS['tile_limit'],
                type=int,
                dest='tile_limit',
            )

        case 'tile_padding':
            parser.add_argument(
                '-p', '-tp',
                help='Padding between tiles on canvas',
                default=ARGS['tile_padding'],
                type=int,
                dest='tile_padding',
            )

        case 'colorset':
            parser.add_argument(
                '-c',
                help=(
                    'List of colors for tiles. '
                    'Can accept #rrggbb, #rgb, r,g,b or :alias values'
                ),
                default=ARGS['colorset'],
                type=str,
                dest='colorset',
                nargs='+'
            )

        case 'color_style':
            parser.add_argument(
                '-m', '-cs',
                help=(
                    'Cell coloring style. May be '
                    ":random, :pulse or :spot"
                ),
                default=ARGS["color_style"],
                type=str,
                choices=(':random', ':pulse', ':spot'),
                dest="color_style",
            )

        # Worm
        case 'move_straight':
            parser.add_argument(
                '-ms',
                help='Allow worm to move straight',
                action='store_const',
                const=not ARGS['move_straight'],
                default=ARGS['move_straight'],
                dest='move_straight'
            )

        case 'move_diagonal':
            parser.add_argument(
                '-md',
                help='Allow worm to move diagonally',
                action='store_const',
                const=not ARGS['move_diagonal'],
                default=ARGS['move_diagonal'],
                dest='move_diagonal'
            )

        case 'move_backwards':
            parser.add_argument(
                '-mb',
                help='Allow worm to move backwards to prevous position',
                action='store_const',
                const=not ARGS['move_backwards'],
                default=ARGS['move_backwards'],
                dest='move_backwards'
            )

        case 'step_min_length':
            parser.add_argument(
                '-smin',
                help='Worm step minimum length',
                default=ARGS['step_min_length'],
                type=int,
                dest='step_min_length',
            )

        case 'step_max_length':
            parser.add_argument(
                '-smax',
                help='Worm step maximum length',
                default=ARGS['step_max_length'],
                type=int,
                dest='step_max_length',
            )

        case 'step_limit':
            parser.add_argument(
                '-l', '-sl', '-lim',
                help='Number of steps for worm to move',
                default=ARGS['step_limit'],
                type=int,
                dest='step_limit',
            )

        case 'colorset':
            parser.add_argument(
                '-c', '-sc',
                help=(
                    'List of colors for step pixels. '
                    'Can accept #rrggbb, #rgb, r,g,b or :alias values'
                ),
                default=ARGS['colorset'],
                type=str,
                dest='colorset',
                nargs='+'
            )

        # Coprimes
        case 'line_length':
            parser.add_argument(
                '-l', '-ll',
                help='Length of one step',
                default=ARGS['line_length'],
                type=int,
                dest='line_length',
            )

        case 'line_thickness':
            parser.add_argument(
                '-t', '-lt',
                help='Thickness of line',
                default=ARGS['line_thickness'],
                type=int,
                dest='line_thickness',
            )

        case 'line_color' if script_name == 'coprimes':
            parser.add_argument(
                '-c', '-lc',
                help='Color of dashes',
                default=ARGS['line_color'],
                type=argtypes.color,
                dest='line_color',
            )

        case 'background_color_a':
            parser.add_argument(
                '-bga',
                help='First background color',
                default=ARGS['background_color_a'],
                type=argtypes.color,
                dest='background_color_a',
            )

        case 'background_color_b':
            parser.add_argument(
                '-bgb',
                help='Second background color',
                default=ARGS['background_color_b'],
                type=argtypes.color,
                dest='background_color_b',
            )

        case 'exclude':
            parser.add_argument(
                '-e',
                help='Exclude figure segments on image',
                default=ARGS['exclude'],
                dest='exclude',
                choices=list(aliases.figures.keys()),
                nargs='+'
            )

        case 'image_width':
            parser.add_argument(
                '-w',
                help=(
                    'Base image width in tiles based on line '
                    'length. Must be coprime with image height'
                ),
                default=ARGS['image_width'],
                type=argtypes.coprime,
                dest='image_width',
            )

        case 'image_height':
            parser.add_argument(
                '-h',
                help=(
                    'Base image height in tiles based on line '
                    'length. Must be coprime with image height'
                ),
                default=ARGS['image_height'],
                type=argtypes.coprime,
                dest='image_height',
            )

        # Puzzles
        case 'tile_side':
            parser.add_argument(
                '-t', '-p',
                help='Side of one puzzle in pixels',
                default=ARGS['tile_side'],
                type=int,
                dest='tile_side',
            )

        case 'ledge_length':
            parser.add_argument(
                '-l',
                help='Length of puzzle ledge in pixels',
                default=ARGS['ledge_length'],
                type=int,
                dest='ledge_length',
            )

        case 'ledge_depth':
            parser.add_argument(
                '-d',
                help='Depth of puzzle ledge in pixels',
                default=ARGS['ledge_depth'],
                type=int,
                dest='ledge_depth',
            )

        case 'line_color':
            parser.add_argument(
                '-lc',
                help='Color of puzzle border',
                default=ARGS['line_color'],
                type=argtypes.color,
                dest='line_color',
            )


def setup(script_name):
    settings = tomllib.load(open('settings.toml', 'rb'))
    ARGS = settings['global'] | settings[script_name]

    helps = {
        'zombatars': {
            'show_bright_colors': argtypes.show_bright_colors,
            'show_common_colors': argtypes.show_common_colors,
            'show_skin_colors': argtypes.show_skin_colors
        },
        'glyphs': {
            'show_glyphsets': argtypes.show_glyphsets,
            'show_colors': argtypes.show_colors,
            'show_colorsets': argtypes.show_colorsets
        },
        'mapper': {
            'show_colors': argtypes.show_colors,
            'show_colorsets': argtypes.show_colorsets
        },
        'worm': {
            'show_colors': argtypes.show_colors,
            'show_colorsets': argtypes.show_colorsets
        },
        'coprimes': {
            'show_colors': argtypes.show_colors
        },
        'puzzles': {
            'show_colors': argtypes.show_colors,
            'show_colorsets': argtypes.show_colorsets
        }
    }.get(script_name, dict())

    # Parse arguments
    parser = argparse.ArgumentParser(
        prog=script_name,
        add_help=False
    )

    for argument in ('help', *helps, *tuple(ARGS)):
        add_argument(argument, parser, ARGS, script_name)

    ARGS.update(dict(parser.parse_args()._get_kwargs()))

    # Resolve nargs+ type values
    if 'colorset' in ARGS:
        ARGS['colorset'] = argtypes.colorset(ARGS['colorset'])

    # Display seed
    if ARGS['show_seed'] and script_name != "coprimes":
        print(f'Seed: {ARGS['seed']}')

    # Dislpay help for aliases and exit
    [helps[helper]() for helper in helps if ARGS[helper]]
    if any([ARGS[helper] for helper in helps]):
        exit(0)

    # print(ARGS)
    return ARGS
from PIL import Image
from random import (
    randint,
    choice
)

from aliases import (
    zombatar_colors
)


def limit(value, min_value, max_value):
    random_value = randint(min_value, max_value)

    if isinstance(value, int):
        return min(max(min_value, value), max_value)
    return random_value


def solve_zcolor(value, color_space):
    colors = zombatar_colors[color_space]
    random_value = choice(tuple(colors.values()))

    if value is None:
        return random_value
    return value


def resize(image, width, height):
    image = image.resize(
        size=(width, height),
        resample=Image.Resampling.BOX
    )

    return image


def show_and_save(image, output, quiet):
    if output:
        try:
            image.save(output)
        except ValueError:
            print(f"Unknown file extension for '{output}'")
            exit(0)

    if not quiet or not output:
        image.show()
import numpy as np
from PIL import (
    Image,
    ImageDraw,
    ImageFont
)

from random import choice

from setup import setup
from utils import (
    resize,
    show_and_save
)

ARGS = setup('glyphs')

if ARGS['by'] == 'tiles':
    ARGS['image_width'] *= ARGS['font_size'] + ARGS['font_padding']
    ARGS['image_width'] += ARGS['font_padding']

    ARGS['image_height'] *= ARGS['font_size'] + ARGS['font_padding']
    ARGS['image_height'] += ARGS['font_padding']

# Create canvas
image = Image.fromarray(np.full(
    (ARGS['image_height'], ARGS['image_width'], 3),
    ARGS['background_color'],
    np.uint8
))

colors = ARGS['colorset']
glyphs = ARGS['glyphset']

# Setup font
draw = ImageDraw.Draw(image)
draw.fontmode = '1' if ARGS['font_aliasing'] else '0'

font = None
try:
    font = ImageFont.truetype(
        ARGS['font_name'],
        ARGS['font_size']
    )
except OSError:
    print(f"Font {ARGS['font_name']} doesn't found, aborting")
    exit(0)

# Draw glyphs
for x in range(
        ARGS['font_padding'],
        ARGS['image_width'],
        ARGS['font_size'] + ARGS['font_padding']
    ):
    for y in range(
            ARGS['font_padding'],
            ARGS['image_height'],
            ARGS['font_size'] + ARGS['font_padding']
        ):
        draw.text(
            xy=(x + ARGS['font_size']//2, y + ARGS['font_size']//2),
            text=choice(glyphs),
            font=font,
            fill=choice(colors),
            anchor='mm'
        )

image = resize(
    image,
    ARGS['image_width'] * ARGS['image_scale_factor'],
    ARGS['image_height'] * ARGS['image_scale_factor']
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
import numpy as np
from PIL import Image

from setup import setup
from utils import (
    resize,
    show_and_save,
    limit,
    solve_zcolor
)

ARGS = setup('zombatars')
samples = 'img/zombatars'

# Image variants in order of rendering
# 
# Element    | Variants with colors    | Unique variants
#     --     |            --           |        --
# Background | 4 + 1*(18)              | 5
# Skin       | 12                      | 12
# Cloth      | 13                      | 13
# Tidbit     | 10 + 5*(18)             | 15
# Accessory  | 13 + 4*(18)             | 17
# Mustache   | 1 + 24*(18)             | 25
# Hair       | 2 + 15*(18)             | 17
# Eyewear    | 5 + 12*(18)             | 17
# Hat        | 2 + 13*(18)             | 15
#     --     |            --           |        --
# Total      | 179_195_575_333_632_000 | 21_555_787_500

background_id = limit(ARGS['background'], 1, 5)
background_color = solve_zcolor(ARGS['background_color'], 'bright')
skin_color = solve_zcolor(ARGS['skin_color'], 'skin')
cloth_id = limit(ARGS['cloth'], 0, 12)
tidbit_id = limit(ARGS['tidbit'], 0, 14)
tidbit_color = solve_zcolor(ARGS['tidbit_color'], 'bright')
accessory_id = limit(ARGS['accessory'], 0, 16)
accessory_color = solve_zcolor(ARGS['accessory_color'], 'bright')
mustache_id = limit(ARGS['mustache'], 0, 24)
mustache_color = solve_zcolor(ARGS['mustache_color'], 'common')
hair_id = limit(ARGS['hair'], 0, 16)
hair_color = solve_zcolor(ARGS['hair_color'], 'common')
eyewear_id = limit(ARGS['eyewear'], 0, 16)
eyewear_color = solve_zcolor(ARGS['eyewear_color'], 'bright')
hat_id = limit(ARGS['hat'], 0, 14)
hat_color = solve_zcolor(ARGS['hat_color'], 'bright')


def color_template_element(element, color):
    if color == (0, 0, 0):  # Skip white color
        return element

    alpha = element.getchannel('A')
    element = element.convert('HSV')

    width, height = element.size
    data = np.array(element)
    
    # Make HSV color shift
    for x in range(height):
        for y in range(width):
            data[x][y][0] = np.array(round(color[0]*256/360))
            data[x][y][1] = np.array(round(color[1]*256/100))

            if data[x][y][2] >= np.array(-round(color[2]*256/100)):
                data[x][y][2] += np.array(round(color[2]*256/100))

            elif data[x][y][2] > np.array(8*256/100):
                data[x][y][2] = np.array(0)

    element = Image.fromarray(data, 'HSV')
    element = element.convert('RGBA')
    element.putalpha(alpha)

    return element


# Background
image = Image.open(f'{samples}/backgrounds/{background_id}.png')
if background_id == 1 and background_color != 1:
    image = color_template_element(
        image, background_color
    )

# Skin
skin = Image.open(f'{samples}/skin.png')
skin = color_template_element(skin, skin_color)
image.paste(skin, (5, 0), skin)

skin = Image.open(f'{samples}/blank.png')
image.paste(skin, (5, 0), skin)

# Cloth
if cloth_id != 0:
    cloth = Image.open(f'{samples}/clothes/{cloth_id}.png')
    image.paste(cloth, (5, 0), cloth)

# Tidbit
if tidbit_id != 0:
    if tidbit_id in (2, 3, 10, 11, 12):
        tidbit = Image.open(f'{samples}/tidbits/{tidbit_id}.png')
        if tidbit_color != 1:
            tidbit = color_template_element(
                tidbit, tidbit_color
            )
    else: 
        tidbit = Image.open(f'{samples}/tidbits/{tidbit_id}.png')
    image.paste(tidbit, (5, 0), tidbit)

# Accessory
if accessory_id != 0:
    if accessory_id in (9, 11, 13, 14):
        accessory = Image.open(
            f'{samples}/accessories/{accessory_id}.png'
        )
        if accessory_color != 1:
            accessory = color_template_element(
                accessory, accessory_color
            )
    else: 
        accessory = Image.open(
            f'{samples}/accessories/{accessory_id}.png'
        )
    image.paste(accessory, (5, 0), accessory)

# Mustache
if mustache_id != 0:
    # Mustache pure color
    mustache = Image.open(f'{samples}/mustaches/{mustache_id}.png')
    if mustache_color != 1:
        mustache = color_template_element(
            mustache, mustache_color
        )
    
    image.paste(mustache, (5, 0), mustache)

    # Mustache black outline
    if mustache_id not in (2, 3, 5, 6, 7, 13, 17, 19, 20):
        mustache = Image.open(f'{samples}/mustaches/{mustache_id}_.png')
        image.paste(mustache, (5, 0), mustache)

# Hair
if hair_id != 0:
    hair = Image.open(f'{samples}/hairs/{hair_id}.png')
    if hair_color != 1:
        hair = color_template_element(
            hair, hair_color
        )
    image.paste(hair, (5, 0), hair)

    if hair_id not in (3, 4, 5, 6, 7, 8, 9, 10, 16):
        hair = Image.open(f'{samples}/hairs/{hair_id}_.png')
        image.paste(hair, (5, 0), hair)

# Eyewear
if eyewear_id != 0:
    eyewear = Image.open(f'{samples}/eyewear/{eyewear_id}.png')
    if eyewear_id not in (13, 14, 15, 16):
        if eyewear_color != 1:
            eyewear = color_template_element(
                eyewear, eyewear_color
            )

        image.paste(eyewear, (5, 0), eyewear)

        eyewear = Image.open(f'{samples}/eyewear/{eyewear_id}_.png')
        image.paste(eyewear, (5, 0), eyewear)

# Hat
if hat_id != 0:
    hat = Image.open(f'{samples}/hats/{hat_id}.png')
    if hat_id == 13:
        image.paste(hat, (5, 0), hat)
    else:
        if hat_color != 1:
            hat = color_template_element(
                hat, hat_color
            )

        image.paste(hat, (5, 0), hat)

        if hat_id not in (2, 4, 5, 10, 12, 14):
            hat = Image.open(f'{samples}/hats/{hat_id}_.png')
            image.paste(hat, (5, 0), hat)

image = image.convert('RGB')
image = resize(
    image,
    180 * ARGS['image_scale_factor'],
    180 * ARGS['image_scale_factor']
)

show_and_save(image, ARGS['output'], ARGS['quiet'])
from os import system
from time import sleep
from copy import deepcopy

from levels import levels

# Colors
white = "\033[0m"
red = "\033[31m"
green = "\033[32m"
yellow = "\033[33m"
blue = "\033[34m"
magenta = "\033[35m"
cyan = "\033[36m"

def print_field():
    system("clear")

    # for raw in field:
        # print(*raw, sep=' ')
    
    for raw in field:
        line = ''.join([str(cell) for cell in raw])

        upper = str.maketrans({
            '0': f"{white}┌─┐ {white}",
            '1': f"{green}╔═╗ {white}",
            '2': f"{red}╔═╗ {white}",
        })

        lower = str.maketrans({
            '0': f"{white}└─┘ {white}",
            '1': f"{green}╚═╝ {white}",
            '2': f"{red}╚═╝ {white}",
        })

        line_upper = line.translate(upper)
        line_lower = line.translate(lower)
            
        print(f"{line_upper}\n{line_lower}")

    print()

def gain_input():
    global current_level

    match input("Ход: "):
        case "w":
            move(0, -1)
        case "a":
            move(-1, 0)
        case "s":
            move(0, 1)
        case "d":
            move(1, 0)
        case "r":
            set_level(current_level)
        case "1":
            current_level -= 1
            set_level(current_level)
        case "2":
            current_level += 1
            set_level(current_level)
        case "e":
            exit()
        case _:
            pass

def set_level(level):
    global levels, field, x, y

    field = deepcopy(levels[level]["field"])
    x = levels[level]["x"]
    y = levels[level]["y"]

    field[y][x] = 1

def next_level():
    global current_level

    input("Следующий уровень")
    
    current_level += 1
    set_level(current_level)

def end_game():
    input("Игра пройдена!")
    exit()

def move(x_vel, y_vel):
    global x, y
    field_max_x = len(field)
    field_max_y = len(field[0])

    if x_vel != 0:
        while 0 <= x + x_vel < field_max_x and field[y][x + x_vel] == 0:
            x += x_vel
            field[y][x] = 1

            print_field()
            sleep(0.05)

    elif y_vel != 0:
        while 0 <= y + y_vel < field_max_y and field[y + y_vel][x] == 0:
            y += y_vel
            field[y][x] = 1
        
            print_field()
            sleep(0.05)

# Init
current_level = 0
field = []

set_level(current_level)
system("clear")
guide = """Управление:
w, a, s, d - Перемещение
1 - Предыдущий уровень
2 - Следующий уровень
r - Сброс уровня
e - Выход
"""

input(guide)

# Run
while True:
    print_field()
    gain_input()

    empty_cells = 0
    for row in field:
        for cell in row:
            if cell == 0:
                empty_cells += 1

    if empty_cells == 0:
        if current_level == len(levels) - 1:
            end_game()
        else:
            next_level()
levels = {
    0: {
        "field": [
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0],
        ],
        "x": 0,
        "y": 4,
    },
    1: {
        "field": [
            [0, 0, 0, 0, 0],
            [0, 0, 0, 2, 0],
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [0, 0, 0, 1, 2],
        ],
        "x": 3,
        "y": 4,
    },
    2: {
        "field": [
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [0, 0, 2, 0, 2],
            [0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0],
        ],
        "x": 4,
        "y": 3,
    },
    3: {
        "field": [
            [0, 0, 0, 0, 0],
            [0, 2, 1, 2, 0],
            [0, 0, 0, 0, 0],
            [0, 2, 2, 0, 2],
            [0, 0, 0, 0, 2],
        ],
        "x": 2,
        "y": 1,
    },
    5: {
        "field": [
            [0, 0, 0, 0, 2],
            [0, 1, 0, 0, 0],
            [0, 0, 0, 2, 0],
            [2, 0, 0, 0, 0],
            [0, 0, 2, 0, 0],
        ],
        "x": 1,
        "y": 1,
    },
    4: {
        "field": [
            [0, 0, 2, 2, 2],
            [0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [2, 2, 0, 0, 0],
        ],
        "x": 1,
        "y": 2,
    },
    5: {
        "field": [
            [0, 0, 2, 0, 0, 0, 0],
            [0, 0, 2, 0, 0, 0, 0],
            [0, 0, 2, 0, 0, 0, 0],
            [0, 0, 2, 0, 0, 0, 0],
            [0, 0, 2, 0, 0, 0, 0],
            [0, 0, 2, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
        ],
        "x": 0,
        "y": 0,
    },
    # ...
}
import re
import locale
from datetime import datetime, timedelta

from matplotlib import ticker
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.dates import DateFormatter

from utils import *
from setup import setup

locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')  # For russian datetime strings

ARGS = setup("creation")
groups = {
    "daily": {
        "re": r"[\d\-]+\s\w+\s\([\d\-]+\)",
        "allowed": ARGS["notes_daily"],
        "color": "tab:orange",
        "legend_title": "Дейли",
    },
    "symmary": {
        "re": r"(И|и)тоги\s.+",
        "tag": "Итоги",
        "allowed": ARGS["notes_symmary"],
        "color": "tab:green",
        "legend_title": "Итоги",
    },
    "dreams": {
        "re": r"(Сон|Сны)\s.+",
        "allowed": ARGS["notes_dreams"],
        "color": "tab:purple",
        "legend_title": "Сны",
    },
    "other": {
        "re": r".+",
        "allowed": ARGS["notes_other"],
        "color": "tab:blue",
        "legend_title": "Другое",
    },
}

day = 24 * 3600
md_files = get_files(ARGS["search"], "*.md")

data = []
creation_times = 0

# File words
for file_path in md_files:
    file_name = get_file_name(file_path)
    file_content = open(file_path, "r").read()
    file_date = re.findall(r"^---.|\n+?---\n\*\*(.+)\*\*\n", file_content)

    if ARGS["exclude_frontmatter"]:
        file_content = re.sub(r"^---(.|\n)+?---\n", '', file_content)

    if ARGS["exclude_date"]:
        file_content = re.sub(r"^\*\*.+\*\*\n", '', file_content)

    file_header = ''.join(re.findall(r"^---(?:.|\n)+?---", file_content))

    # Get file group
    for group in groups:
        if "re" in groups[group]:
            if re.match(groups[group]["re"], file_name):
                file_group = group
                break

        elif "tag" in groups[group]:
            if group[group]["tag"] in file_header:
                file_group = group
                break

    # Add file data to statistics
    if groups[file_group]["allowed"]:
        creation_date = get_file_creation_time(file_path)

        creation_time = creation_date.replace(year=1970, month=1, day=1, tzinfo=timezone.utc)

        data.append((file_path, creation_time, file_group))
        # print(file_words, file_path)

if ARGS["sort_values"]:
    data = sorted(data, key=lambda val: val[1], reverse=True)

# Split all data on lists
files = [i[0] for i in data]
creation_times = [i[1] for i in data]
colors = [groups[i[2]]["color"] for i in data]

# Create plot
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(13.5, 5.7),
)

fig.canvas.manager.set_window_title("Время создания файлов")
ax = list(axs.items())

legend_elements = [
    Patch(
        facecolor=groups[group]["color"],
        edgecolor="black",
        linewidth=.5,
        label=groups[group]["legend_title"],
    ) for group in groups if groups[group]["allowed"]
]

ax[0][1].legend(handles=legend_elements)

def format_coord(x, y):
    x = int(x+.5)

    if not 0 <= x < len(files):
        return ""

    return f"{get_file_name(files[x])}\nВремя создания: {creation_times[x].strftime("%H:%M:%S")}"

ax[0][1].format_coord = format_coord

ax[0][1].scatter(range(len(creation_times)), creation_times, color=colors, edgecolor="black", linewidth=1)
ax[0][1].margins(0.005, 0.01)

ax[0][1].xaxis.set_visible(False)

ax[0][1].set_ylim(datetime(1970, 1, 1), datetime(1970, 1, 2))
ax[0][1].yaxis.set_major_locator(ticker.MultipleLocator(1 / 10))
ax[0][1].yaxis.set_major_formatter(DateFormatter("%H:%M"))

plt.tight_layout()
plt.show()
import re
from yaml import safe_load
from collections.abc import Iterable

from matplotlib import ticker
import matplotlib.pyplot as plt
from matplotlib.patches import Patch

from utils import *
from setup import setup

ARGS = setup("workout")
groups = {
    "pull-ups": {
        "color": "tab:blue",
        "legend_title": "Подтягивания"
    },
    "push-ups": {
        "color": "tab:orange",
        "legend_title": "Отжимания"
    }
}

md_files = get_files(ARGS["search"], "*.md")

data = []

# File words
for file_path in md_files:
    file_name = get_file_name(file_path)
    file_content = open(file_path, "r").read()

    # Count only daily notes
    if not re.match(r"[\d\-]+\s\w+\s\([\d\-]+\)", file_name):
        continue

    frontmatter = ''.join(re.findall(r"^---(?:.|\n)+?---\n", file_content))
    frontmatter = safe_load(frontmatter[:-5])

    pull_ups = frontmatter["pull-ups"][0] if "pull-ups" in frontmatter else []
    push_ups = frontmatter["push-ups"][0] if "push-ups" in frontmatter else []

    if pull_ups or push_ups:
        data.append((file_path, pull_ups, push_ups))

def deep_sum(item):
    total = 0
    for value in item:
        if isinstance(value, Iterable):
            total += deep_sum(value)
        else:
            total += value

    return total

if ARGS["sort_values"]:
    data = sorted(data, key=lambda val: deep_sum(val[1]) + deep_sum(val[2]), reverse=True)

# Split all data on lists
files = [i[0] for i in data]
pull_ups = [i[1] for i in data]
push_ups = [i[2] for i in data]

total_push_ups = sum([sum(v) for v in pull_ups])
total_pull_ups = sum([sum(v) for v in push_ups])

print("Всего подтягиваний:", total_push_ups)
print("Всего отжиманий:", total_pull_ups)
print("Подтягиваний в день в среднем:", round(total_push_ups / len(push_ups), 2))

# Create plot
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(13.5, 5.7),
)

fig.canvas.manager.set_window_title("Подтягивания и отжимания")
ax = list(axs.items())

legend_elements = [
    Patch(
        facecolor=groups[group]["color"],
        edgecolor="black",
        linewidth=.5,
        label=groups[group]["legend_title"],
    ) for group in groups
]

ax[0][1].legend(handles=legend_elements)

def format_coord(x, y):
    x = int(x-.5)

    if not 0 <= x < len(files):
        return ""

    return f"{get_file_name(files[x])}\n{pull_ups[x]} = {sum(pull_ups[x])}, {push_ups[x]} = {sum(push_ups[x])}"

ax[0][1].format_coord = format_coord

# Generate bar plot
for i, pulls in enumerate(zip(pull_ups, push_ups)):
    bottom = 0
    for pull_up in pulls[0]:
        ax[0][1].bar(i + 1, pull_up, bottom=bottom, width=1, color="tab:blue", edgecolor="black", linewidth=1)
        bottom += pull_up

    for push_up in pulls[1]:
        ax[0][1].bar(i + 1, push_up, bottom=bottom, width=1, color="tab:orange", edgecolor="black", linewidth=1)
        bottom += push_up

max_pulls = lambda pulls: sum(max(pulls, key=lambda v: sum(v)))  # Get max by sum in list of lists

ax[0][1].margins(x=0)

ax[0][1].set_ylim(0, max(max_pulls(pull_ups), max_pulls(push_ups)) + 5)

ax[0][1].xaxis.set_major_locator(ticker.AutoLocator())

plt.tight_layout()
plt.show()
import re
import webbrowser
from urllib.parse import quote

from utils import *
from setup import setup

ARGS = setup("links")

md_files = get_files(ARGS["search"], "*.md")
file_names = [
    get_file_name(file)
    for file in get_files(ARGS["index"], "*.md")
]

links = {}
attachments = []
headers = []
dailies = []

for file_path in md_files:
    file_name = get_file_name(file_path, ".md")

    file_content = open(file_path, "r").read()

    # Get header from daily note
    if re.match(r"[\d\-]+\s\w+\s\([\d\-]+\)", file_name):
        file_content = re.sub(r"^---(.|\n)+?---\n", '', file_content)
        header = next(iter(re.findall(r"\*\*\*\n(.+)", file_content)), "Без заголовка")

        header = header.strip(" .")  # Remove trailings
        header = re.sub(r"\[\[.+?\|\]\]", "", header)          # Remove unvisible links
        header = re.sub(r"\[\[.+?\|(.+?)\]\]", r"\1", header)  # And open visible links
        header = re.sub(r"\[\[(.+?)\]\]", r"\1", header)       # And open obvious links

        if len(header) > 100:
            header = header[:97] + "..."

        dailies.append(file_name)
        headers.append(header)

    # Grep raw links and attachments
    raw_links = re.findall(r"\[\[.+?\]\]", open(file_path, "r").read())

    for raw_link in raw_links:
        # Grep link name
        attachment = re.findall(r"(?<=\[\[)(.+?)(?=\]\]|\\|\|)", raw_link)[0]

        if attachment.endswith((".png", ".jpg", ".jpeg", ".gif", ".mov", ".wav", ".mp4", ".mp3", "m4a")):
            if attachment not in attachments and re.match(ARGS["search_filter"], attachment.split('/')[-1]):
                attachments.append(attachment)
            continue

        if attachment in file_names:
            continue

        # True link (non created file)
        links.setdefault(attachment, 0)
        links[attachment] += 1

# Make file with links
file = open(ARGS["output_file"], "w+")
file.write("***\n")

def stringify(array):
    return '`, `'.join(
        [i[len(ARGS["path"]) + 1:] for i in array]
    )

file.write(f"Индекс: `{stringify(ARGS["index"])}`\n")
file.write(f"Поиск: `{stringify(ARGS["search"])}`\n")
file.write(f"Фильтр: `{ARGS["search_filter"]}`\n")

sorters = {
    "Alpha": None,
    "Debut": lambda _: 0,
    "Frequency": lambda link: -links[link],
}

if ARGS["add_links"]:
    file.write(f"##### Ссылки ({len(links)})\n")
    for link in sorted(links, key=sorters[ARGS["sort"]]):
        file.write(f"[[{link}]]\n")

if ARGS["add_headers"]:
    file.write(f"##### Заголовки ({len(headers)})\n")
    for daily, header in zip(dailies, headers):
        file.write(f"[[{daily}|{header}]]\n")

if ARGS["add_attachments"]:
    file.write(f"##### Вложения ({len(attachments)})\n\n")
    if ARGS["reverse"]:
        attachments.reverse()

    for attachment in attachments:
        file.write(f"![[{attachment}]]\n\n")

file.close()
print(f"Записано в {ARGS["output_file"]}")

if not ARGS["open_automaticly"]:
    exit()

vault = ARGS["path"].split("/")[-1]
file_name = ARGS["output_file"][len(ARGS["path"]) + 1:].replace(".md", '')

obsidian_url = f"obsidian://open?vault={quote(vault)}&file={quote(file_name)}"
webbrowser.open(obsidian_url)
import re

from matplotlib import ticker
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from json import dumps

from utils import *
from setup import setup

ARGS = setup("keys")
groups = {
    "ru": {
        "re": r"[А-яЕеЁё]+",
        "allowed": ARGS["symbols_ru"],
        "color": "tab:orange",
        "legend_title": "Русский",
    },
    "en": {
        "re": r"[A-Za-z]",
        "allowed": ARGS["symbols_en"],
        "color": "tab:blue",
        "legend_title": "Английский",
    },
    "nu": {
        "re": r"[0-9]",
        "allowed": ARGS["symbols_numbers"],
        "color": "tab:green",
        "legend_title": "Цифры",
    },
    "pn": {
        "re": r"[!\"#$%&'()*+,\-./:;<=>?@\\\[\]\^_`{|}~]",
        "allowed": ARGS["symbols_punctuation"],
        "color": "tab:gray",
        "legend_title": "Пунктуация",
    },
    "ws": {
        "re": r"\s",
        "allowed": ARGS["symbols_whitespace"],
        "color": "tab:red",
        "legend_title": "Разделители",
    },
    "un": {
        "re": r".",
        "allowed": ARGS["symbols_un"],
        "color": "tab:purple",
        "legend_title": "Другое",
    },
}

md = get_files(ARGS["search"], "*.md")

data = {}
letters = 0

# File words
for file_path in md:
    file_name = get_file_name(file_path)
    file_content = open(file_path, "r").read()

    if ARGS["exclude_frontmatter"]:
        file_content = re.sub(r"^---(.|\n)+?---", '', file_content)

    if ARGS["exclude_date"]:
        file_content = re.sub(r"^\n\*\*.+\n", '', file_content)

    for letter in file_content:
        if not ARGS["case_sensitive"]:
            letter = letter.upper()

        filter_letters = ARGS["allowed_symbols"] != "Any"
        letter_allowed = not filter_letters

        if filter_letters and letter in ARGS["allowed_symbols"]:
            letter_allowed = True

        # Get letter group
        for group in groups:
            if re.match(groups[group]["re"], letter):
                letter_group = group
                break

        # Add letter data to statistics
        if groups[letter_group]["allowed"] and letter_allowed:
            if letter not in data:
                data[letter] = [0, letter_group]

            letters += 1
            data[letter][0] += 1

data = [(char, *data[char]) for char in data]
data = sorted(data, key=lambda val: val[1], reverse=True)

letters = [i[0] for i in data]
entrances = [i[1] for i in data]
colors = [groups[i[2]]["color"] for i in data]

total_entrances = sum(entrances)

if ARGS["output_popularity_dict"]:
    print(dumps({item[0]: item[1] for item in data}, ensure_ascii=False, indent=2))

# Change special symbols to escaped
for j in range(len(letters)):
    for s, i in {"\n": "\\n", "\t": "\\t"}.items():
        letters[j] = letters[j].replace(s, i)

print(f"Символов: {total_entrances:,}")

totals = {i[2]: 0 for i in data}
for i in data:
    totals[i[2]] += i[1]

for group in sorted(totals, key=lambda key: totals[key], reverse=True):
    print(f"{groups[group]["legend_title"]}: {totals[group]:,}")

# Create plot
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(13.5, 5.7),
)

fig.canvas.manager.set_window_title("Частотный анализ")
ax = list(axs.items())

legend_elements = [
    Patch(
        facecolor=groups[group]["color"],
        edgecolor="black",
        linewidth=.5,
        label=groups[group]["legend_title"],
    ) for group in groups if groups[group]["allowed"]
]

ax[0][1].legend(handles=legend_elements)

def format_coord(x, y):
    x = int(x+.5)

    if not 0 <= x < len(letters):
        return ""

    left_sum = sum(entrances[:x + 1]) / total_entrances
    right_sum = sum(entrances[x + 1:]) / total_entrances

    return (
        f"Символ {x + 1}: \"{letters[x]}\"\n"
        f"Повторений: {entrances[x]} "
        f"({entrances[x] / total_entrances:.2%}) "
        f"(слева: {left_sum:.2%}, справа: {right_sum:.2%})"
    )

ax[0][1].format_coord = format_coord

ax[0][1].bar(range(len(entrances)), entrances, color=colors, width=1, edgecolor="black", linewidth=.5)
ax[0][1].margins(0)

ax[0][1].set_xticks(range(len(entrances)), letters)

if ARGS["display_mode"] == "Percentages":
    ax[0][1].yaxis.set_major_formatter(ticker.PercentFormatter(total_entrances))

ax[0][1].yaxis.set_major_locator(ticker.MultipleLocator(max(entrances) / 10))

plt.tight_layout()
plt.show()
import re
from yaml import safe_load

import matplotlib.pyplot as plt

from utils import *
from setup import setup

ARGS = setup("teacups")
groups = {
    "tea-cups": {
        "color": "tab:purple",
        "legend_title": "Чайные кружки"
    },
}

md_files = get_files(ARGS["search"], "*.md")

data = []

# File words
for file_path in md_files:
    file_name = get_file_name(file_path)
    file_content = open(file_path, "r").read()

    # Count only daily notes
    if not re.match(r"[\d\-]+\s\w+\s\([\d\-]+\)", file_name):
        continue

    frontmatter = ''.join(re.findall(r"^---(?:.|\n)+?---\n", file_content))
    frontmatter = safe_load(frontmatter[:-5])

    tea_cups = frontmatter["tea-cups"][0] if "tea-cups" in frontmatter else []

    if tea_cups:
        data.append((file_path, tea_cups))


if ARGS["sort_values"]:
    data = sorted(data, key=lambda pair: pair[1], reverse=True)

# Split all data on lists
files = [i[0] for i in data]
tea_cups = [i[1] for i in data]

total_tea_cups = sum(tea_cups)

print("Всего кружек:", total_tea_cups)
print("Кружек в день в среднем:", round(total_tea_cups / len(tea_cups), 2))

# Create plot
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(13.5, 5.7),
)

fig.canvas.manager.set_window_title("Чайные кружки")
ax = list(axs.items())

def format_coord(x, y):
    x = int(x-.5)

    if not 0 <= x < len(files):
        return ""

    return f"{get_file_name(files[x])}\nЧайных кружек: {tea_cups[x]}"

ax[0][1].format_coord = format_coord

# Generate step plot
ax[0][1].step(
    range(len(tea_cups) + 2),
    [tea_cups[0]] + tea_cups + [tea_cups[-1]],  # Extend borders
    linewidth=2,
    where="mid",
    label=groups["tea-cups"]["legend_title"],
    color=groups["tea-cups"]["color"]
)

plt.fill_between(
    [i + 0.5 for i in range(len(tea_cups) + 1)],
    [tea_cups[0]] + tea_cups,
    step="pre",
    alpha=0.4,
    color=groups["tea-cups"]["color"]
)

ax[0][1].legend()
ax[0][1].set_xlim(.5, len(files) + .5)
ax[0][1].set_xticks(range(1, len(tea_cups) + 1))
ax[0][1].set_ylim(0, max(tea_cups) + 3)

plt.tight_layout()
plt.show()
import re
import webbrowser
import json

from urllib.parse import quote
from random import choice
from pymystem3 import Mystem
from os import path

from utils import *
from setup import setup

ARGS = setup("blur")

md_files = get_files(ARGS["search"], "*.md")
m = Mystem()

tokens_usage = dict()
words = 0

# Load data from dump file, if it exists
data_hash = hash(len(md_files))

if path.exists(".tokens_usage"):
    dump = json.load(open(".tokens_usage", "r"))

    if dump["hash"] == data_hash:
        tokens_usage = dump["tokens_usage"]
        words = dump["words"]

# Or get token usage statistics
if not tokens_usage:
    for file_path in md_files:
        file_name = get_file_name(file_path)
        file_content = open(file_path, "r").read()

        if ARGS["exclude_frontmatter"]:
            file_content = re.sub(r"^---(.|\n)+?---", '', file_content)

        if ARGS["exclude_date"]:
            file_content = re.sub(r"^\n\*\*.+\n", '', file_content)

        # Get tokens
        file_content = file_content.lower()
        file_content = ' '.join(re.findall(r"[а-яeё-]+", file_content))
        file_content = re.sub(r"\W-+\W", ' ', file_content)

        file_tokens = [
            token for token in m.lemmatize(file_content)
            if not re.match(r"[\s-]+", token)
        ]

        # Update usage
        for file_token in file_tokens:
            tokens_usage.setdefault(file_token, 0)
            tokens_usage[file_token] += 1

        words += len(file_tokens)

    with open(".tokens_usage", "w+") as output:
        json.dump(
            {"hash": data_hash, "tokens_usage": tokens_usage, "words": words},
            output,
            ensure_ascii=False,
            indent=2
        )

tokens_usage = dict(sorted(tokens_usage.items(), key=lambda val: -val[1]))

# Process inserted file
file = find_file(ARGS["input_file"], md_files)
if not file:
    file = choice(md_files)

file_name = get_file_name(file)
file_content = open(file, "r").read()

file_frontmatter = re.findall(r"^---(?:.|\n)+?---", file_content)[0]
file_date = re.findall(r"\n\*\*.+\n", file_content)[0]

file_content = file_content.removeprefix(file_frontmatter)
file_content = file_content.removeprefix(file_date)

keys = list(tokens_usage.keys())
values = list(tokens_usage.values())

metric = {
    "Rating": lambda lex: (keys.index(lex) if lex in tokens_usage else len(tokens_usage)) + 1,
    "Frequency": lambda lex: tokens_usage.get(lex, 0) / words,
    "Coverage": lambda lex: sum(values[:keys.index(lex)]) / words if lex in tokens_usage else 1
}[ARGS["metric"]]

operator = {
    "lt": lambda a, b: a < b,
    "le": lambda a, b: a <= b,
    "gt": lambda a, b: a > b,
    "ge": lambda a, b: a >= b,
}[ARGS["operator"]]

blurred = 0
total = 0
shift = 0

# Split ![[images]], [[links]], [web links](), ```code```, `inline-code`, $regex$ and common words
for match in re.finditer(r"!?\[\[.+?(?:\|.*?)*?\]\]|\[.+?\]\(.+?\)|`(?:.|\n)+?`|\$(?:.|\n)+?\$|\w+(?:-\w+)?", file_content):
    word = match.group(0)

    if word.startswith(("![[", "[[", "[", "$", "`")) or word.isnumeric():
        continue

    start = match.start() + shift
    end = match.end() + shift

    lex = m.lemmatize(word)
    lex = lex[0] if len(lex) else word

    total += 1
    if operator(metric(lex), ARGS["treshold"]):
        file_content = f"{file_content[:start]}=={word}=={file_content[end:]}"
        blurred += 1
        shift += 4

# Write file
output = open(ARGS["output_file"], "w+")

output.write(file_frontmatter)
output.write(f"{file_date[:-3]} [[{file_name}|...]]**\n")
output.write(file_content)

output.close()
m.close()

print(f"Заблюрено: {blurred} ({blurred / total:.2%})")
print(f"Записано в {ARGS["output_file"]}")

if not ARGS["open_automaticly"]:
    exit()

vault = ARGS["path"].split("/")[-1]
file_name = ARGS["output_file"][len(ARGS["path"]) + 1:].replace(".md", '')

obsidian_url = f"obsidian://open?vault={quote(vault)}&file={quote(file_name)}"
webbrowser.open(obsidian_url)
import argparse
import tomllib

def int_or_str(data):
    try:
        return int(data)
    except ValueError:
        return str(data)

def add_argument(argument, parser, ARGS):
    match argument:
        case "help":
            parser.add_argument(
            "-help",
            action="help",
            default=argparse.SUPPRESS,
            help="Show all script startup parameters and exit"
        )

        case "sort_values":
            parser.add_argument(
                "-sort",
                help="Sort values on plot by it's frequency",
                action="store_const",
                const=not ARGS["sort_values"],
                default=ARGS["sort_values"],
                dest="sort_values",
            )

        case "sort":
            parser.add_argument(
                "-sort",
                help="Sort values on plot by selected parameter: Debut, Phrequency, Alpha, Hue",
                type=str,
                default=ARGS["sort"],
                dest="sort",
            )

        case "notes_daily":
            parser.add_argument(
                "-d",
                help="Display statistics for daily notes",
                action="store_const",
                const=not ARGS["notes_daily"],
                default=ARGS["notes_daily"],
                dest="notes_daily",
            )

        case "notes_dreams":
            parser.add_argument(
                "-D",
                help="Display statistics for dream notes",
                action="store_const",
                const=not ARGS["notes_dreams"],
                default=ARGS["notes_dreams"],
                dest="notes_dreams",
            )

        case "notes_symmary":
            parser.add_argument(
                "-S",
                help="Display statistics for symmary notes",
                action="store_const",
                const=not ARGS["notes_symmary"],
                default=ARGS["notes_symmary"],
                dest="notes_symmary",
            )

        case "notes_other":
            parser.add_argument(
                "-o",
                help="Display statistics for notes without current type",
                action="store_const",
                const=not ARGS["notes_other"],
                default=ARGS["notes_other"],
                dest="notes_other",
            )

        case "symbols_ru":
            parser.add_argument(
                "-r",
                help="Display russian symbols in statistics",
                action="store_const",
                const=not ARGS["symbols_ru"],
                default=ARGS["symbols_ru"],
                dest="symbols_ru",
            )

        case "symbols_en":
            parser.add_argument(
                "-e",
                help="Display english symbols in statistics",
                action="store_const",
                const=not ARGS["symbols_en"],
                default=ARGS["symbols_en"],
                dest="symbols_en",
            )

        case "symbols_un":
            parser.add_argument(
                "-u",
                help="Display other unicode symbols in statistics",
                action="store_const",
                const=not ARGS["symbols_un"],
                default=ARGS["symbols_un"],
                dest="symbols_un",
            )

        case "symbols_numbers":
            parser.add_argument(
                "-n",
                help="Display numbers in statistics",
                action="store_const",
                const=not ARGS["symbols_numbers"],
                default=ARGS["symbols_numbers"],
                dest="symbols_numbers",
            )

        case "symbols_punctuation":
            parser.add_argument(
                "-p",
                help="Display punctuation symbols in statistics",
                action="store_const",
                const=not ARGS["symbols_punctuation"],
                default=ARGS["symbols_punctuation"],
                dest="symbols_punctuation",
            )

        case "symbols_whitespace":
            parser.add_argument(
                "-w",
                help="Display whitespace symbols in statistics",
                action="store_const",
                const=not ARGS["symbols_whitespace"],
                default=ARGS["symbols_whitespace"],
                dest="symbols_whitespace",
            )

        case "case_sensitive":
            parser.add_argument(
                "-c",
                help="Case sensitive search",
                action="store_const",
                const=not ARGS["case_sensitive"],
                default=ARGS["case_sensitive"],
                dest="case_sensitive",
            )

        case "allowed_symbols":
            parser.add_argument(
                "-s",
                help="String of allowed symbols to search for",
                type=str,
                default=ARGS["allowed_symbols"],
                dest="allowed_symbols",
            )

        case "output_popularity_dict":
            parser.add_argument(
                "-d",
                help="Output dictionary of keys with it's pupularity ",
                action="store_const",
                const=not ARGS["output_popularity_dict"],
                default=ARGS["output_popularity_dict"],
                dest="output_popularity_dict",
            )

        case "show_tokens":
            parser.add_argument(
                "-t",
                help="Output all tokens",
                action="store_const",
                const=not ARGS["show_tokens"],
                default=ARGS["show_tokens"],
                dest="show_tokens",
            )

        case "lemmatize":
            parser.add_argument(
                "-w",
                help="Reduce word forms to it's lemmas",
                action="store_const",
                const=not ARGS["lemmatize"],
                default=ARGS["lemmatize"],
                dest="lemmatize",
            )

        case "search":
            parser.add_argument(
                "-i",
                help="Set search folder",
                default=ARGS["search"],
                type=str,
                dest="search",
                nargs="+",
            )

        case "add_headers":
            parser.add_argument(
                "-h",
                help="Include headers to summary file",
                action="store_const",
                const=not ARGS["add_headers"],
                default=ARGS["add_headers"],
                dest="add_headers",
            )

        case "add_links":
            parser.add_argument(
                "-l",
                help="Include links to summary file",
                action="store_const",
                const=not ARGS["add_links"],
                default=ARGS["add_links"],
                dest="add_links",
            )

        case "add_attachments":
            parser.add_argument(
                "-a",
                help="Include attachments to summary file",
                action="store_const",
                const=not ARGS["add_attachments"],
                default=ARGS["add_attachments"],
                dest="add_attachments",
            )

        case "reverse":
            parser.add_argument(
                "-r",
                help="Reverse order",
                action="store_const",
                const=not ARGS["reverse"],
                default=ARGS["reverse"],
                dest="reverse",
            )

        case "exclude_file":
            parser.add_argument(
                "-e",
                help="List of tokens to exclude",
                default=ARGS["exclude_file"],
                type=str,
                dest="exclude_file",
            )

        case "max_tokens":
            parser.add_argument(
                "-m",
                help="Limit max numbers of tokens on usage plot",
                default=ARGS["max_tokens"],
                type=int,
                dest="max_tokens",
            )

        case "label_threshold":
            parser.add_argument(
                "-l",
                help="Density after which token will be displayed as separated bar on plot of token usage by length",
                default=ARGS["label_threshold"],
                type=float,
                dest="label_threshold",
            )

        case "word_type":
            parser.add_argument(
                "-f",
                help="Display tokens only of selected type (https://yandex.ru/dev/mystem/doc/ru/grammemes-values)",
                default=ARGS["word_type"],
                type=str,
                dest="word_type",
                nargs="+"
            )

        case "search_filter":
            parser.add_argument(
                "-f",
                help="Filter attachments by it's name",
                default=ARGS["search_filter"],
                type=str,
                dest="search_filter",
            )

        case "input_file":
            parser.add_argument(
                "-f",
                help="Input file to be processed with script",
                default=ARGS["input_file"],
                type=str,
                dest="input_file",
            )

        case "metric":
            parser.add_argument(
                "-m",
                help="Method to check token rating",
                default=ARGS["metric"],
                type=str,
                choices=["Rating", "Frequency", "Coverage"],
                dest="metric",
            )

        case "treshold":
            parser.add_argument(
                "-t",
                help="Value of rating for token to be blurred",
                default=ARGS["treshold"],
                type=float,
                dest="treshold",
            )

        case "operator":
            parser.add_argument(
                "-o",
                help="Qualifier of the token blur condition relative to the threshold value",
                default=ARGS["operator"],
                type=str,
                choices=["lt", "le", "gt", "ge"],
                dest="operator",
            )

        case "yscale_log":
            parser.add_argument(
                "-ylog",
                help="Set logarithmic scale for y axis",
                action="store_const",
                const=not ARGS["yscale_log"],
                default=ARGS["yscale_log"],
                dest="yscale_log",
            )

        case "pallete":
            parser.add_argument(
                "-p",
                help="Filter only colors from selected pallete",
                default=ARGS["pallete"],
                type=str,
                dest="pallete",
            )

def setup(script_name):
    settings = tomllib.load(open("settings.toml", "rb"))

    # Get settings
    ARGS = settings["global"] | settings[script_name]

    options = {}
    if "options" in ARGS:
        options = ARGS.pop("options")
        ARGS |= options

    # Parse arguments
    parser = argparse.ArgumentParser(add_help=False)
    add_argument("help", parser, ARGS)

    for argument in ARGS:
        add_argument(argument, parser, ARGS)

    parsed_args = dict(parser.parse_args()._get_kwargs())
    for arg in parsed_args:
        ARGS[arg] = parsed_args[arg]

    # Configure all paths based on vault path
    if "output_file" in ARGS:
        ARGS["output_file"] = f"{ARGS["path"]}/{ARGS["output_file"]}"

    if isinstance(ARGS["search"], str):
        ARGS["search"] = [ARGS["search"]]

    for i in range(len(ARGS["search"])):
        ARGS["search"][i] = f"{ARGS["path"]}/{ARGS["search"][i]}"

    if "index" in ARGS:
        for i in range(len(ARGS["index"])):
            ARGS["index"][i] = f"{ARGS["path"]}/{ARGS["index"][i]}"

    # Enable all options if none are selected
    active_options = sum(ARGS[option] for option in options)

    if active_options == 0:
        for option in options:
            ARGS[option] = True

    # print(ARGS)
    return ARGS
import re
import yaml
import locale

from os import stat
from pathlib import Path
from datetime import datetime, timedelta
from datetime import timezone

locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')  # For russian datetime strings

def get_files(paths, search_filter, hard_filter=True):
    file_paths = list()

    for path in paths:
        path = Path(path)

        if path.is_dir():
            file_paths.extend(list(path.rglob(search_filter)))

        elif path.is_file():
            file_paths.append(path)

    if hard_filter:
        return sorted(file_paths, key=lambda file_path: get_file_creation_time(file_path))

    return sorted(file_paths, key=lambda file_path: get_file_birthtime(file_path)) 

def get_file_creation_time(file_path) -> datetime:
    if not str(file_path).endswith((".md", ".txt")):
        return get_file_birthtime(file_path)

    file_content = open(file_path, "r").read()
    creation_times = {
        "file": get_file_birthtime(file_path),
        "yaml": get_yaml_birthtime(file_content),
        "header": get_header_birthtime(file_content),
    }

    # Find better timestamp of creation time
    if creation_times["yaml"]:
        return creation_times["yaml"]

    if not creation_times["header"] or abs(creation_times["header"] - creation_times["file"]) < timedelta(minutes=2):
        return creation_times["file"]

    return creation_times["header"]

def get_file_birthtime(file_path):
    current_utc_offset = timezone(datetime.now().astimezone().utcoffset())
    file_birthtime = datetime.fromtimestamp(stat(file_path).st_birthtime, tz=current_utc_offset)

    return file_birthtime

def get_yaml_birthtime(file_content):
    iso_time_in_yaml = r"---\n(\s{2}\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{2}:\d{2})\n---"
    frontmatter = re.match(iso_time_in_yaml, file_content, re.DOTALL)

    if frontmatter:
        frontmatter = frontmatter.group(1)

        file_metadata: dict = yaml.safe_load(frontmatter)
        metadata_birthtime = file_metadata.get("birthtime")

        if metadata_birthtime:
            return datetime.strptime(metadata_birthtime, "%Y-%m-%dT%H:%M:%S%z\n")
        return None

def get_header_birthtime(file_content): 
    current_utc_offset = timezone(datetime.now().astimezone().utcoffset())
    time_header_in_note = r"\*\*(\w+,\s\d+\s\w+\s\d+г.\s\d+:\d+)\*\*"
    file_data_header = re.search(time_header_in_note, file_content)

    if file_data_header:
        file_data_header = file_data_header.group(1)

        obsidian_creation_time = datetime.strptime(file_data_header, "%A, %d %B %Yг. %H:%M")
        obsidian_creation_time = obsidian_creation_time.replace(tzinfo=current_utc_offset)

        return obsidian_creation_time

    return None

def find_file(file_name, paths):
    for path in paths:
        if get_file_name(path) == get_file_name(file_name):
            return path

    return False

def get_file_name(file_path, extension=".md"):
    return Path(file_path).name.replace(extension, '')

def get_file_size(file_path):
    return Path(file_path).stat().st_size  # Bytes
from matplotlib import ticker
import matplotlib.pyplot as plt
from matplotlib.patches import Patch

from utils import *
from setup import setup

ARGS = setup("density")
groups = {
    "file": {
        "extensions": [
            ".md",
        ],
        "color": "tab:orange",
        "legend_title": "Текстовые файлы",
    },
    "image": {
        "extensions": [
            ".png",
            ".gif",
            ".jpg",
            ".jpeg",
            ".gif",
        ],
        "color": "tab:blue",
        "legend_title": "Изображения",
    },
    "audio": {
        "extensions": [
            ".wav",
            ".mp3",
            ".m4a",
        ],
        "color": "tab:green",
        "legend_title": "Аудио",
    },
    "video": {
        "extensions": [
            ".mov",
            ".mp4",
        ],
        "color": "tab:red",
        "legend_title": "Видео",
    }
}

files = get_files(ARGS["search"], "*.*")

data = {
    group: {
        "files": 0,
        "sizes": 0,
        "biggest_file": {
            "name": 0,
            "size": 0,
        }
    } for group in groups
}

for file_path in files:
    file_name = get_file_name(file_path, "")
    founded = False

    for group in groups:
        for extension in groups[group]["extensions"]:
            if file_name.endswith(extension):
                file_size = get_file_size(file_path)

                data[group]["files"] += 1
                data[group]["sizes"] += file_size

                if file_size > data[group]["biggest_file"]["size"]:
                    data[group]["biggest_file"]["name"] = get_file_name(file_path, extension)
                    data[group]["biggest_file"]["size"] = file_size

                founded = True
                break

        if founded:
            break

    # if not founded:
    #     print("No group for", file_path)

files_total = sum([data[group]["files"] for group in groups])
sizes_total = sum([data[group]["sizes"] for group in groups])

files_groups = data.keys()
sizes_groups = data.keys()

if ARGS["sort_values"]:  # Sort groups generation order
    files_groups = [i[0] for i in sorted(data.items(), key=lambda item: item[1]["files"])]
    sizes_groups = [i[0] for i in sorted(data.items(), key=lambda item: item[1]["sizes"])]

# Create plot
fig, axs = plt.subplot_mosaic(
    [
        ["by_files"],
        ["by_sizes"],
    ],
    figsize=(13.5, 5.7),
)

fig.canvas.manager.set_window_title("Плотности")
ax = list(axs.items())

legend_elements = [
    Patch(
        facecolor=groups[group]["color"],
        edgecolor="black",
        linewidth=.5,
        label=groups[group]["legend_title"],
    ) for group in groups
]

ax[0][1].legend(handles=legend_elements)
ax[1][1].legend(handles=legend_elements)

def formatter(x, pos=0):
    if x >= 10**9:
        return f"{x / 10**9:.2f} ГБ"
    elif x >= 10**6:
        return f"{x / 10**6:.2f} МБ"
    else:
        return f"{x / 10**3:.2f} КБ"

def format_coord(x, y):
    left = 0

    for group in files_groups:
        left += data[group]["files"]

        if left >= x:
            title = groups[group]['legend_title']
            files = data[group]['files']
            percentages = files / files_total

            x_percentages = x / files_total
            x = round(x)

            return f"{title}: {files} ({percentages:.2%})\n x={x} ({x_percentages:.2%})"

    return ""

ax[0][1].format_coord = format_coord

def format_coord(x, y):
    left = 0

    for group in sizes_groups:
        left += data[group]["sizes"]

        if left >= x:
            title = groups[group]['legend_title']
            size = data[group]['sizes']
            percentages = size / sizes_total

            x_percentages = x / sizes_total
            x = round(x)

            return f"{title}: {formatter(size)} ({percentages:.2%})\n x={formatter(x)} ({x_percentages:.2%})"

    return ""

ax[1][1].format_coord = format_coord

print("Всего файлов:", files_total)
print("Общий объём:", formatter(sizes_total))
print()
print("Самые большие файлы:")

biggest_files = sorted([data[group]["biggest_file"] for group in groups], key=lambda v: v["size"])
for file in biggest_files:
    if file["size"] != 0:
        print(file["name"], formatter(file["size"]))

# Generate plots
for i, space in enumerate(("files", "sizes")):
    left = 0

    if ARGS["sort_values"]:
        data = dict(sorted(data.items(), key=lambda item: item[1][space]))

    for group in [files_groups, sizes_groups][i]:
        ax[i][1].barh(0, data[group][space], left=left, height=1, color=groups[group]["color"], edgecolor="black", linewidth=1)
        left += data[group][space]

    ax[i][1].xaxis.set_major_locator(ticker.MultipleLocator(left / 10))
    ax[i][1].get_yaxis().set_visible(False)
    ax[i][1].margins(0)

ax[0][1].set_title("Распределение файлов по типу", loc="left")

ax[1][1].set_title("Распределение файлов по объёму", loc="left")
ax[1][1].xaxis.set_major_formatter(formatter)

plt.tight_layout()
plt.show()
import re
from statistics import mean, median

from matplotlib import ticker
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from utils import *
from setup import setup

ARGS = setup("words")
groups = {
    "daily": {
        "re": r"[\d\-]+\s\w+\s\([\d\-]+\)",
        "allowed": ARGS["notes_daily"],
        "color": "tab:orange",
        "legend_title": "Дейли",
    },
    "symmary": {
        "re": r"(И|и)тоги\s.+",
        "tag": "Итоги",
        "allowed": ARGS["notes_symmary"],
        "color": "tab:green",
        "legend_title": "Итоги",
    },
    "dreams": {
        "re": r"(Сон|Сны)\s.+",
        "allowed": ARGS["notes_dreams"],
        "color": "tab:purple",
        "legend_title": "Сны",
    },
    "other": {
        "re": r".+",
        "allowed": ARGS["notes_other"],
        "color": "tab:blue",
        "legend_title": "Другое",
    },
}

word_patterns = {
    "NWC": r"[^\s]+",
    "Obsidian": r"(?:[0-9]+(?:(?:,|\.)[0-9]+)*|[\-'’A-Za-z\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC஀-௿가-힣ꥠ-ꥼힰ-ퟆ])+|[\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u4E00-\u9FD5\uAC00-\uD7A3\uA960-\uA97C\uD7B0-\uD7C6]"
}

md_files = get_files(ARGS["search"], "*.md")

data = []
words = 0

# File words
for file_path in md_files:
    file_name = get_file_name(file_path)
    file_content = open(file_path, "r").read()

    if ARGS["exclude_frontmatter"]:
        file_content = re.sub(r"^---(.|\n)+?---", '', file_content)

    if ARGS["exclude_date"]:
        file_content = re.sub(r"^\n\*\*.+\n", '', file_content)

    file_header = ''.join(re.findall(r"^---(?:.|\n)+?---", file_content))
    file_words = len(re.findall(word_patterns[ARGS["word_pattern"]], file_content))

    # Get file group
    for group in groups:
        if "re" in groups[group]:
            if re.match(groups[group]["re"], file_name):
                file_group = group
                break

        elif "tag" in groups[group]:
            if group[group]["tag"] in file_header:
                file_group = group
                break

    # Add file data to statistics
    if groups[file_group]["allowed"]:
        data.append((file_path, file_words, file_group))
        words += file_words

        # print(file_words, file_path)

if ARGS["sort_values"]:
    data = sorted(data, key=lambda val: val[1], reverse=True)

# Split all data on lists
files = [i[0] for i in data]
words = [i[1] for i in data]
colors = [groups[i[2]]["color"] for i in data]

print(f"Слов: {sum(words)}")
print(f"Медиана: {median(words)}")
print(f"Среднее: {mean(words):.2f}")

# Create plot
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(13.5, 5.7), 
)

fig.canvas.manager.set_window_title("Число слов")
ax = list(axs.items())

legend_elements = [
    Patch(
        facecolor=groups[group]["color"],
        edgecolor="black",
        linewidth=.5,
        label=groups[group]["legend_title"],
    ) for group in groups if groups[group]["allowed"]
]

ax[0][1].legend(handles=legend_elements)

def format_coord(x, y):
    x = int(x+.5)

    if not 0 <= x < len(files):
        return ""

    return f"{get_file_name(files[x])}\nСлов: {words[x]}"

ax[0][1].format_coord = format_coord

ax[0][1].bar(range(len(words)), words, color=colors, width=1, linewidth=.5)
ax[0][1].margins(0)

ax[0][1].get_xaxis().set_visible(False)

ax[0][1].yaxis.set_major_locator(ticker.MultipleLocator(max(words) / 10))

plt.tight_layout()
plt.show()
import re
from pymystem3 import Mystem
from matplotlib import ticker
import matplotlib.pyplot as plt

from utils import *
from setup import setup

ARGS = setup("lemmas")
groups = {
    "daily": {
        "re": r"[\d\-]+\s\w+\s\([\d\-]+\)",
        "allowed": ARGS["notes_daily"],
    },
    "symmary": {
        "re": r"(И|и)тоги\s.+",
        "tag": "Итоги",
        "allowed": ARGS["notes_symmary"],
    },
    "dreams": {
        "re": r"(Сон|Сны)\s.+",
        "allowed": ARGS["notes_dreams"],
    },
    "other": {
        "re": r".+",
        "allowed": ARGS["notes_other"],
    },
}

exclude = [] if ARGS["exclude_file"] == False else [
    *open(ARGS["exclude_file"], encoding="utf-8").read().splitlines()  
]

allowed = sum([groups[group]["allowed"] for group in groups])
if allowed == 0:
    for group in groups:
        groups[group]["allowed"] = True

md_files = get_files(ARGS["search"], "*.md")
m = Mystem()

tokens = set()
excluded_tokens = set()

tokens_usage = dict()
total_tokens_by_length = {}

data = [("Начальное состояние", 0)]
words = 0

for file_path in md_files:
    file_name = get_file_name(file_path)
    file_content = open(file_path, "r").read()

    file_header = ''.join(re.findall(r"^---(?:.|\n)+?---", file_content))

    if ARGS["exclude_frontmatter"]:
        file_content = re.sub(r"^---(.|\n)+?---", '', file_content)

    if ARGS["exclude_date"]:
        file_content = re.sub(r"^\n\*\*.+\n", '', file_content)

    file_content = file_content.lower()
    file_content = ' '.join(re.findall(r"[а-яеё-]+", file_content))
    file_content = re.sub(r"\W-+\W", ' ', file_content)

    # Get file group
    for group in groups:
        if "re" in groups[group]:
            if re.match(groups[group]["re"], file_name):
                file_group = group
                break

        elif "tag" in groups[group]:
            if group[group]["tag"] in file_header:
                file_group = group
                break

    # Add file data to statistics
    if groups[file_group]["allowed"]:
        if ARGS["lemmatize"] or ARGS["word_type"]:
            clean_analysis = list(
                filter(
                    lambda v: v != {"text": ' '},
                    m.analyze(file_content)
                )
            )

            analysis = (
                (i["text"], i["analysis"][0]["lex"], i["analysis"][0]["gr"]) 
                if "analysis" in i and len(i["analysis"]) else
                (i["text"], False, False)
                for i in clean_analysis
            )

        else:
            analysis = ((i, False, False) for i in file_content.split())

        # Filter gathered tokens
        file_tokens = []

        for token in analysis:
            lex = token[1] if token[1] and ARGS["lemmatize"] else token[0]
            word = token[0]
            gr = token[2].replace('=', ',').split(',')[0] if token[2] else False

            if not re.match(r"[\s-]+", lex) and (not ARGS["word_type"] or gr in ARGS["word_type"]):
                if lex not in exclude:
                    file_tokens.append(lex)
                else:
                    excluded_tokens.add(f"{word} ({lex})")

        if ARGS["update_by"] == "Note":
            tokens.update(file_tokens)

            words += len(file_tokens)
            data.append((file_path, len(tokens)))

        else:  # Update graph by word
            for token in file_tokens:
                tokens.add(token)

                words += 1
                data.append((token, len(tokens)))

        for token in file_tokens:
            tokens_usage.setdefault(token, 0)
            tokens_usage[token] += 1

        # print(file_content, file_tokens, len(file_tokens), file_path)

# Gracefully close mystem
m.close()

files = [i[0] for i in data]
history = [i[1] for i in data]

tokens_usage = dict(sorted(tokens_usage.items(), key=lambda val: -val[1]))

tokens = [i for i in tokens_usage]
usage = [tokens_usage[i] for i in tokens_usage]

# By unique tokens
unique_tokens_by_length = {}
for token in tokens:
    if len(token) not in unique_tokens_by_length:
        unique_tokens_by_length[len(token)] = 1
    else:
        unique_tokens_by_length[len(token)] += 1

sorting=lambda val: -val[1] if ARGS["sort_values"] else val[0]

unique_tokens_by_length = dict(sorted(unique_tokens_by_length.items(), key=sorting))
total_tokens_by_length = {i: {} for i in range(1, len(max(tokens, key=lambda v: len(v))) + 1)}

for token, pair in tokens_usage.items():
    total_tokens_by_length[len(token)][token] = pair

for key in total_tokens_by_length:
    pair = total_tokens_by_length[key]
    total_tokens_by_length[key] = dict(sorted(pair.items(), key=lambda v: -v[1]))

if ARGS["show_tokens"]:
    print(f"Токены: \n{'\n'.join(sorted(tokens))}\n")

    if ARGS["exclude_file"]:
        print(f"Исключённые слова: \n{'\n'.join(sorted(excluded_tokens))}\n")

assert words == sum(usage)

print(f"Слов: {words}")
print(f"Токенов: {len(tokens)} ({len(tokens) / words:.2%})")

# Get longest tokens
max_word_length = len(max(tokens, key=lambda val: len(val) if val.count('-') == 0 else 0))
longest_tokens = [
    token for token in tokens
    if len(token) == max_word_length and token.count('-') == 0
]

print(f"Максимальная длина токена:", max_word_length)
print(f"Самые длинные токены:", ', '.join(longest_tokens))

print(f"Сравнение антонимов:")
print("Да:", tokens_usage["да"])
print("Нет:", tokens_usage["нет"])
print("Начало:", tokens_usage["начало"])
print("Конец:", tokens_usage["конец"])
print("Кот:", tokens_usage["кот"])
print("Собака:", tokens_usage["собака"])
print("Война:", tokens_usage["война"])
print("Мир:", tokens_usage["мир"])

print("\nСамые популярные токены:")
for i in range(10):
    # print(f"| {tokens[.c} | {usage[i]} | {usage[ i] / words:.2%|")
    print(f"{i + 1}: {tokens[i]}, повторений: {usage[i]} ({usage[i] / words:.2%})")

# Create plot
fig, axs = plt.subplot_mosaic(
    [["lemmas growth", "lemmas by length"],
     ["lemmas usage", "words usage by length"]],
    figsize=(13.5, 5.7), 
)

fig.canvas.manager.set_window_title(f"{"Лемматический" if ARGS["lemmatize"] else "Словарный"} анализ")
ax = list(axs.items())

# Unique tokens history
def format_coord(x, y):
    x = int(x+.5)

    if not 1 <= x < len(files):
        return ""

    new_tokens = history[x] - history[x-1]
    total = history[x]

    return (
        f"{get_file_name(files[x])}\n"
        f"Новых токенов: {new_tokens} (Всего: {total})"
    ) if ARGS["update_by"] == "Note" else (
        f"Токен: {files[x]} {"(новый)" if new_tokens > 0 else ''}\n"
        f"Всего: {total}"
    )

ax[0][1].set_title("Рост уникальных токенов", loc="left")
# ax[0][1].set_xlabel("Запись" if ARGS["update_by"] == "Note" else "Слово")
# ax[0][1].set_ylabel("Уникальных токенов")

ax[0][1].format_coord = format_coord

ax[0][1].plot(range(len(history)), history)
ax[0][1].margins(0)

if ARGS["update_by"] == "Note":
    ax[0][1].get_xaxis().set_visible(False)
else:
    ax[0][1].xaxis.set_major_locator(ticker.MultipleLocator(words / 10))

ax[0][1].yaxis.set_major_locator(ticker.MultipleLocator(max(history) / 10))

# Token distribution by length
def format_coord(x, y):
    x = int(x+.5)

    if not 0 <= x < len(unique_tokens_by_length):
        return ""

    keys = list(unique_tokens_by_length.keys())
    values = list(unique_tokens_by_length.values())

    left_sum = sum(values[:x + 1]) / sum(values)
    right_sum = sum(values[x + 1:]) / sum(values)

    return (
        f"Уникальных токенов длины {keys[x]}: {values[x]} ({values[x] / sum(values):.2%})\n"
        f"Слева: {left_sum:.2%}, Справа: {right_sum:.2%}"
    )

ax[1][1].set_title("Распределение уникальных токенов по длине", loc="left")
# ax[1][1].set_ylabel("Плотность")
# ax[1][1].set_xlabel("Длина токена")

ax[1][1].format_coord = format_coord

ax[1][1].bar(range(len(unique_tokens_by_length)), unique_tokens_by_length.values(), width=1, edgecolor="black", linewidth=.5)
ax[1][1].set_xticks(range(len(unique_tokens_by_length)))
ax[1][1].set_xticklabels(unique_tokens_by_length.keys())

ax[1][1].margins(0)

if ARGS["display_mode"] == "Percentages":
    ax[1][1].yaxis.set_major_formatter(ticker.PercentFormatter(sum(unique_tokens_by_length.values())))
ax[1][1].yaxis.set_major_locator(ticker.MultipleLocator(max(unique_tokens_by_length.values()) / 10))

# Token usage rate
def format_coord(x, y):
    x = int(x)

    if not 0 <= x < len(tokens):
        return ""

    token = tokens[x]
    rating = x + 1

    left_sum = sum(usage[:x + 1]) / words
    right_sum = sum(usage[x + 1:]) / words

    return (
        f"Токен: {token}, Рейтинг: {rating}, Частота: {usage[x]} ({usage[x] / words:.2%})\n"
        f"Слева: {left_sum:.2%}, Справа: {right_sum:.2%}"
    )

# Add limit annotation
if ARGS["max_tokens"]:
    limit = f" (топ {ARGS["max_tokens"]})"
else:
    limit = ""

ax[2][1].set_title("Частота использования токенов" + limit, loc="left")
# ax[2][1].set_xlabel("Токен")
# ax[2][1].set_ylabel("Число повторений")

ax[2][1].format_coord = format_coord

# ax[2][1].bar(range(len(usage)), usage, width=1)
ax[2][1].stairs(usage, [i for i in range(len(usage) + 1)], fill=True)
ax[2][1].margins(0)

view_width = len(usage) if not ARGS["max_tokens"] else ARGS["max_tokens"]

ax[2][1].set_xlim(0, view_width)
ax[2][1].xaxis.set_major_formatter(lambda x, pos: tokens[i].capitalize() if 0 <= (i := int(x)) < len(tokens) else '-')
ax[2][1].xaxis.set_major_locator(ticker.MultipleLocator((view_width - 1) / 5, .5))

ax[2][1].yaxis.set_major_locator(ticker.MultipleLocator(max(usage) / 10))

# Token popularity by length
def format_coord(x, y):
    x = int(x-.5)

    if not 0 <= x < len(total_tokens_by_length):
        return ""

    keys = tuple(total_tokens_by_length.keys())
    values = tuple(tuple(i.values()) for i in total_tokens_by_length.values())

    left_sum = sum(sum(i) for i in values[:x + 1]) / words
    right_sum = sum(sum(i) for i in values[x + 1:]) / words

    return (
        f"Токенов длины {keys[x]}: {sum(values[x])} ({sum(values[x]) / words:.2%})\n"
        f"Слева: {left_sum:.2%}, Справа: {right_sum:.2%}"
    )

ax[3][1].set_title("Частота использования токенов по длине", loc="left")
# ax[3][1].set_xlabel("Длина токена")
# ax[3][1].set_ylabel("Плотность")

ax[3][1].format_coord = format_coord

bottom = 0
for length in total_tokens_by_length:
    stack = 0
    bottom = 0

    # Display separated bars for wide tokens
    for key, value in total_tokens_by_length[length].items():
        if value / words >= ARGS["label_threshold"]:
            ax[3][1].bar(length, value, width=1, bottom=bottom, edgecolor="black", linewidth=.5, color="tab:blue")
            ax[3][1].text(x=length, y=bottom + value / 2, s=key, va="center", ha="center", clip_on=True, fontsize=10 - len(key) * 0.8)

            bottom += value
            stack = 0
        else:
            stack += value

    # Append all other stack
    if stack != 0:
        ax[3][1].bar(length, stack, width=1, bottom=bottom, edgecolor="black", linewidth=.5, color="tab:blue")

ax[3][1].margins(0)

ax[3][1].xaxis.set_major_locator(ticker.MultipleLocator(1))

if ARGS["display_mode"] == "Percentages":
    ax[3][1].yaxis.set_major_formatter(ticker.PercentFormatter(words))
ax[3][1].yaxis.set_major_locator(ticker.MultipleLocator(max([sum(total_tokens_by_length[key].values()) for key in total_tokens_by_length]) / 10))

plt.tight_layout()
plt.show()
from PIL import Image
import matplotlib.pyplot as plt
from matplotlib import ticker

import colorsys

from utils import *
from setup import setup

ARGS = setup("colors")

# Gather data
image_paths = get_files(ARGS["search"], "*.png", hard_filter=False)
colors = {}

palletes = {
    "Ressurect": (
        "/Users/catalyst/Library/Application Support/Steam/steamapps/common/"
        "Aseprite/Aseprite.app/Contents/Resources/data/palettes/Resurrect.png"
    ),
    "ZX-Spectrum": (
        "/Users/catalyst/Library/Application Support/Steam/steamapps/common/"
        "Aseprite/Aseprite.app/Contents/Resources/data/extensions/hardware-palettes/zx-spectrum.gpl"
    ),
}

# Parse selected pallete
if ARGS["pallete"]:
    pallete_file: str = palletes[ARGS["pallete"]]

    if pallete_file.endswith(".png"):
        image = Image.open(pallete_file)

        rgbs = image.getpalette()
        pallete_colors = tuple(tuple([*rgbs[i:i+3], 255]) for i in range(0, len(rgbs), 3))

        for color in pallete_colors:
            colors[color] = 0

    elif pallete_file.endswith(".gpl"):
        for pallete_color in open(pallete_file).readlines():
            pallete_color = pallete_color.split()

            if len(pallete_color) >= 3 and all(color.isdigit() for color in pallete_color[:3]):
                color = tuple([*(int(rgb) for rgb in pallete_color[:3]), 255])
                colors[color] = 0

# Get colors from drawings
total_images = 0
for image_path in image_paths:
    if "Рисование - " not in str(image_path):
        continue

    image = Image.open(image_path).convert("RGBA")
    image_pallete = image.getcolors()

    if image_pallete is None:
        continue

    total_images += 1
    for count, color in image_pallete:
        # Add alpha channel for RGB images
        if len(color) == 3:
            color = (*color, 255)

        # Return all transparent colors into one
        if color[3] == 0:
            color = (0, 0, 0, 0)

        if not ARGS["pallete"] or ARGS["pallete"] and color in colors:
            colors[color] = colors.get(color, 0) + count

# Order values
data = colors.items()

def get_hue(rgba):
    r, g, b, a = [x / 255.0 for x in rgba]
    h, s, v = colorsys.rgb_to_hsv(r, g, b)
    return h

if ARGS["sort"].lower() in "frequency":
    data = sorted(data, key=lambda v: -v[1])

elif ARGS["sort"].lower() in "hue":
    data = sorted(data, key=lambda v: get_hue(v[0]))

colors = [color for color, _ in data]
counts = [count for _, count in data]

# Output info
print(f"Обработано файлов: {total_images}")
print(f"Уникальных цветов: {len(colors)}")
print(f"Всего пикселей: {sum(counts):,}")

# Create plot
fig, axs = plt.subplot_mosaic(
    [["main"]],
    figsize=(13.5, 5.7),
)

def format_coord(x, y):
    x = int(x-.5)

    if not 0 <= x < len(colors):
        return ""

    return (
       f"Цвет {x+1}: {colors[x]} слева: {sum(counts[:x]) / sum(counts):.2%}\n"
       f"Повторений: {counts[x]:,} ({counts[x] / sum(counts):.2%})" 
    )

fig.canvas.manager.set_window_title("Частотный анализ цветов")
axs["main"].format_coord = format_coord

axs["main"].bar(
    range(1, len(colors) + 1),
    counts,
    color=[[rgb / 255 for rgb in color] for color in colors],
    width=1,
    edgecolor="black",
    linewidth=0.5 if len(colors) < 500 else 0
)

if ARGS["yscale_log"]:
    axs["main"].set_yscale("log")
    axs["main"].set_ylim(1, max(counts))
else:
    if ARGS["display_mode"] == "Percentages":
        axs["main"].yaxis.set_major_formatter(ticker.PercentFormatter(sum(counts)))

    axs["main"].yaxis.set_major_locator(ticker.MultipleLocator(max(counts) / 10))

axs["main"].margins(0)
axs["main"].xaxis.set_major_locator(ticker.MultipleLocator(5 if len(colors) < 500 else len(colors) // 20))

plt.tight_layout()
plt.show()
from time import time, sleep
from threading import Thread
import tomllib

from pynput.keyboard import Controller, Listener, Key
keyboard = Controller()

# Setup
with open("settings.toml", "rb") as f:
    settings = tomllib.load(f)

session = []
tag = settings["DEFAULT_TAG"]

timestamp = 0
state = "begin"

run = {
    "time": 0,
    "note": ""
}

class KEY:
    BEGIN = settings["KEY"]["BEGIN"]
    BEGIN_ALT = settings["KEY"]["BEGIN_ALT"]

    PAUSE = settings["KEY"]["PAUSE"]
    PAUSE_ALT = settings["KEY"]["PAUSE_ALT"]

    NOTE = settings["KEY"]["NOTE"]
    NOTE_ALT = settings["KEY"]["NOTE_ALT"]

class TIMEOUT:
    SMALL = settings["TIMEOUT"]["SMALL"]
    MEDIUM = settings["TIMEOUT"]["MEDIUM"]
    BIG = settings["TIMEOUT"]["BIG"]

# Shortcut actions
def re_enter():
    keyboard.tap(Key.esc)
    sleep(TIMEOUT.SMALL)
    
    for _ in range(5):
        keyboard.tap(Key.down)
        sleep(TIMEOUT.SMALL)

    keyboard.tap(Key.enter)
    sleep(TIMEOUT.SMALL)

    keyboard.tap(Key.up)
    keyboard.tap(Key.enter)
    
    sleep(TIMEOUT.BIG)

    keyboard.tap(Key.enter)
    sleep(TIMEOUT.SMALL)

    keyboard.tap(Key.enter)

def pause():
    keyboard.tap(Key.esc)

def shortcut(function, begin_state, final_state, start_delay=0):
    def inner(function, begin_state, final_state, start_delay):
        global state

        state = begin_state
        sleep(start_delay)
        function()
        state = final_state
    
    # Execute shortcut without delays in main script
    Thread(
        target=inner,
        args=(
            function,
            begin_state,
            final_state,
            start_delay
        )
    ).start()

def on_press(key):
    global timestamp, state, session, run

    if hasattr(key, 'char'):
        key_code = key.char
    else:
        key_code = key.name

    match state, key_code:
        case _, "shift_r":
            return False

        # Main run mode
        case ("begin", KEY.BEGIN | KEY.BEGIN_ALT):
            timestamp = time()
            run = {
                "time": 0,
                "note": "",
            }

            state = "run"

        case ("run", KEY.BEGIN | KEY.BEGIN_ALT) | ("note", "enter"):
            run["time"] += time() - timestamp
            session.append(run)

            timestamp = time()
            run = {
                "time": 0,
                "note": "",
            }
            
            shortcut(re_enter, "re_enter", "run", TIMEOUT.MEDIUM if state == "note" else TIMEOUT.SMALL)

        # Pause mode
        case ("run", "esc"):
            run["time"] += time() - timestamp
            state = "pause"

        case ("run", KEY.PAUSE | KEY.PAUSE_ALT):
            run["time"] += time() - timestamp
            shortcut(pause, "pausing", "pause")

        case ("pause", KEY.PAUSE | KEY.PAUSE_ALT | "enter" | "esc" | "space"):
            timestamp = time()
            shortcut(pause, "unpausing", "run")

        # Note mode
        case ("run", KEY.NOTE | KEY.NOTE_ALT):
            state = "note"
        
        case "note", "esc":
            timestamp = time()
            run["note"] = ""
            state = "run"

        case "note", "backspace":
            run["note"] = run["note"][:-1]

        case "note", "space":
            run["note"] += " "

        case "note", _:
            if hasattr(key, 'char'):
                run["note"] += key.char

    print(f"key: {key}".ljust(20), end=" | ")
    print(f"state: {state}".ljust(20), end=" | ")
    print(f"run: {len(session) + 1} {run['note']}".ljust(20))

with Listener(on_press=on_press) as listener:
    listener.join()

# Extend save
with open("save.toml", "a+") as f:
    for run in session:
        f.write(f"[[{tag}]]\n")
        f.write(f"time = {run['time']}\n")
        f.write(f'note = "{run['note']}"\n\n')

# Load all save
with open("save.toml", "rb") as f:
    save = tomllib.load(f)

# Stats by session
if len(session):
    print("\nSession")
    print(f"Runs: {len(session)}")
    print(f"Average time: {round(sum([run['time'] for run in session]) / len(session))}s")

    # Loot
    if any([run["note"] for run in session]) :
        print("\nLoot")
        for run in session:
            if run["note"]:
                print(run["note"])

# Global stats
if tag in save:
    print(f"\nGlobal")
    print(f"Runs: {len(save[tag])}")
    print(f"Average time: {round(sum([run['time'] for run in save[tag]]) / len(save[tag]))}s")
for ITERS in range(80 + 1):
    level = [1]  # The root of the tree contains only "1"
    results = {}  # This will hold the relationships for the graph

    for c in range(ITERS):
        print("Iter:", ITERS, "c:", c)

        newlevel = set()  # This will be the set of numbers in the level above us
        for x in level:  # We now loop through each number in our current level
            # There will only sometimes be an odd multiple of 3 (plus one) above us
            # When (x-1) mod 3 is 0, x is an even number half the time
            # So we check against (x-4) mod 6 because we don't want to find evens
            odd = (x - 1) // 3 if not (x - 4) % 6 else 0
            if odd > 1: # We don't want 1 (the root) or 0 (no odd found)
                newlevel.add(odd) # Put this into the next level
                results[odd] = x # Add a relationship to the graph

            newlevel.add(x*2)  # There will always be an even number above us
            results[x*2] = x  # Add a relationship to the graph

        # Finally, advance to the next level
        level = newlevel

    # Write dot file for graph
    with open(f"out/graph-{ITERS}.txt", "w", encoding="utf-8") as file:
        file.write("digraph G {\n")
        file.write("\tnode [shape=plaintext width=0.1 fontsize=32];\n")
        file.write("\tedge [dir=none];\n")
        file.write('\tmode="sgd";\n')
        file.write("\troot=1;\n")

        for x in results:
            file.write(f"\t{x} -> {results[x]};\n")
        file.write('}\n')

    # with open("data.js", "w", encoding="utf-8") as file:
    #     file.write("var data = {\n")
    #     file.write("  nodes: [")

    #     file.write(f"\n    {{id: 1}},")
    #     for x in results:
    #         file.write(f"\n    {{id: {x}}},")
    #     file.write('\n  ],\n')

    #     file.write("  links: [")
    #     for x in results:
    #         file.write(f"\n    {{source: {x}, target: {results[x]}}},")
    #     file.write("\n  ]")
    #     file.write("\n}\n")

    # print(f"Generated {len(results)} nodes")
"Generated"

import matplotlib.pyplot as plt
import numpy as np

def collatz_sequence(n):
    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

# Get user input with validation
number = int(input("Число для анализа: "))

# Generate Collatz sequence
sequence = collatz_sequence(number)
iterations = list(range(len(sequence)))

# Calculate y-axis upper limit (5% above max value)
y_max = max(sequence) * 1.05

# Create plot with specified styling
fig = plt.figure(figsize=(12.5, 5.7))
fig.canvas.manager.set_window_title(f"Гипотеза Коллатца")

plt.plot(
    iterations,
    sequence,
    color="tab:purple",
    linewidth=3
)

# Set ticks and limits
if len(iterations) > 30:
    step = max(1, len(iterations) // 30)  # Calculate step size
    plt.xticks(iterations[::step])
else:
    plt.xticks(iterations)

plt.yticks(np.linspace(1, y_max, 10, dtype=int))
plt.ylim(1, y_max)  # Set y-axis limits from 1 to y_max

# Remove margins
plt.margins(x=0, y=0)

# Add labels and title
plt.title(f'История падения числа {number}')
plt.xlabel('Итерация')
plt.ylabel('Значение')

# Remove grid and adjust layout
plt.grid(False)
plt.tight_layout()
plt.show()import math

from time import sleep
from time import time

modulo = 0
inverse_modulo = 0


def initialize_modulo(m):
    global modulo, inverse_modulo

    modulo = m
    inverse_modulo = float(1) / float(m)


def mul_mod(a, b):
    q = int(inverse_modulo * float(a) * float(b))
    return a*b - q*modulo


def sum_mul_mod(a, b, c, d):
    q = int(inverse_modulo * (float(a)*float(b) + float(c)*float(d)))
    return a*b + c*d - q*modulo


def easy_round(x):
    full_double = float(2**53)

    y = x + full_double
    y -= full_double

    return y


def extended_gcd(a):
    A0, A1 = 1, 0
    r0, r1 = a, modulo

    while r1 > 0:
        q = r0 // r1

        A0, A1 = A1, A0 - q * A1
        r0, r1 = r1, r0 - q * r1

    return r0, A0


def inv_mod(a):
    a = a % modulo

    if a < 0:
        a += modulo

    gcd, A = extended_gcd(a)

    if gcd != 1:
        print("Error, gcd should be 1")
        exit()

    return A


def pow_mod(a, b):
    r = 1

    while True:
        if b & 1:
            r = mul_mod(r, a)

        b >>= 1
        if b == 0:
            break

        a = mul_mod(a, a)

    return r


def sum_binomial_mod(n, k):
    if k > n / 2:
        s = pow_mod(2, n) - sum_binomial_mod(n, n - k - 1)
        if s < 0:
            s += modulo

        return s

    prime_factors = []
    mm = modulo
    for p in range(3, int(math.sqrt(mm)) + 1, 2):
        if mm % p == 0:
            mm //= p

            if p <= k:
                prime_factors.append(p)

            while mm % p == 0:
                mm //= p

    if mm > 1 and mm <= k:
        prime_factors.append(mm)

    binomial_powers = [1] * len(prime_factors)
    next_denom = [pf for pf in prime_factors]
    next_num = [pf * (n // pf) for pf in prime_factors]

    binomial_num0, binomial_denom = 1, 1
    sum_num = 1
    binomial_secondary = 1

    for j in range(1, k + 1):
        # New binomial: b(n, j) = b(n, j - 1) * (n - j + 1) / j
        binomial_secondary_update = 0
        num = n - j + 1
        denom = j

        for i, p in enumerate(prime_factors):
            # Test if p is a prime factor of num0
            if next_num[i] == n - j + 1:
                binomial_secondary_update = 1
                next_num[i] -= p
                binomial_powers[i] *= p
                num //= p

                while num % p == 0:
                    binomial_powers[i] *= p
                    num //= p

            # Test if p is a prime factor of denom0
            if next_denom[i] == j:
                binomial_secondary_update = 1
                next_denom[i] += p
                binomial_powers[i] //= p
                denom //= p

                while denom % p == 0:
                    binomial_powers[i] //= p
                    denom //= p

        if binomial_secondary_update:
            binomial_secondary = 1
            for binomial_power in binomial_powers:
                binomial_secondary = mul_mod(binomial_secondary, binomial_power)

        binomial_num0 = mul_mod(binomial_num0, num)
        binomial_denom = mul_mod(binomial_denom, denom)

        if binomial_secondary != 1:
            sum_num = sum_mul_mod(sum_num, denom, binomial_num0, binomial_secondary)
        else:
            sum_num = mul_mod(sum_num, denom) + binomial_num0

    sum_num = mul_mod(sum_num, inv_mod(binomial_denom))
    return sum_num


def digits_of_fraction(n, a, b):
    initialize_modulo(b)
    power = pow_mod(10, n)
    c = mul_mod(power, a)

    return float(c) / float(b)


def digits_of_series(n, m):
    x = float()

    for k in range(0, m, 2):
        x += (
            digits_of_fraction(n, 4, 2 * k + 1) -
            digits_of_fraction(n, 4, 2 * k + 3)
        )

        x = x - easy_round(x)

    return x


def digits_of_pi(n):
    logn = math.log(float(n))
    M = 2 * int(3. * n / logn / logn / logn)  # M is even
    N = 1 + int(  # n >= N
        (n + 15.) * math.log(10.) / (1. + math.log(2. * M))
    )

    N += N % 2  # N should be even
    m_max = M * N + N

    x = digits_of_series(n, m_max)

    for k in range(N):
        m = 2 * M * N + 2 * k + 1
        initialize_modulo(m)

        s = sum_binomial_mod(N, k)
        s = mul_mod(s, pow_mod(5, N))
        s = mul_mod(s, pow_mod(10, n - N))  # n - N is always positive
        s = mul_mod(s, 4)

        x += (2 * (k % 2) - 1) * float(s) / float(m)  # 2*(k % 2) - 1 = (-1)^(k - 1)
        x = x - math.floor(x)

    return x


def PDC(n):
    assert n > 50, "Error, n should be bigger than 50"

    x = digits_of_pi(n)
    pow = 1.e9
    y = x * pow

    while pow > 10 and (y - math.floor(y) < 0.05 or y - math.floor(y) > 0.95):
        pow /= float(10)
        y = x * pow

    y = str(math.floor(y))
    return y


# Compute digits in base 10
if __name__ == "__main__":
    PAUSE_MIN_TIME = 0.05

    # PDC doesn't works before 51 digit
    n = 51
    prefix = "π = 3.141592653589793238462643383279502884197169399375105"

    # Start printing
    try:
        for key in prefix:
            print(key, end='', flush=True)
            sleep(PAUSE_MIN_TIME)

        trace = PDC(n)

        def trace_join(prev: str, new: str):
            for s in range(len(new)):
                if (pos := prev.find(new[:len(new) - s], -10)) != -1:
                    prev = prev[:pos] + new

                    return prev

        while True:
            timestamp = time()

            delta = time() - timestamp
            trace = trace_join(trace, PDC(n))

            if delta < PAUSE_MIN_TIME:
                sleep(PAUSE_MIN_TIME - delta)

            print(trace[n - 51], end='', flush=True)
            n += 1
            
    except KeyboardInterrupt:
        # Delete ^C character and print ellipsis
        print("\b\b", end='', flush=True)
        print("...")
from math import floor
from time import time
from time import sleep


def mod(x, n):
    x %= n
    return  x + n if x < 0 else x


def modPow(b, e, m):
    b = b % m;
    y = 1

    while (e > 0):
        if (e & 1): y = (y * b) % m
        b = (b * b) % m
        e >>= 1

    return y


def S(j, n):
    # Left sum
    left = 0
    for k in range(0, n + 1):
        r = 8 * k + j
        left = mod((left + modPow(16, n - k, r) / r), 1)

    # Right sum
    right = 0
    k = n + 1
    while True:
        rnew = right + 16 ** (n - k) / (8 * k + j)
        if right == rnew: break
        right = rnew

        k += 1

    return left + right


def BBP(d, n):
    d -= 1

    return hex(
        floor(
            16 ** n * mod(4 * S(1, d) - 2 * S(4, d) - S(5, d) - S(6, d), 1)
        )
    )[2:]  # Remove 0x prefix


# Compute digits in base 16
if __name__ == "__main__":
    PAUSE_MIN_TIME = 0.05

    n = 1
    prefix = "π = 3."

    # Start printing
    try:
        for key in prefix:
            print(key, end='', flush=True)
            sleep(PAUSE_MIN_TIME)

        while True:
            timestamp = time()
            trace = BBP(n, 1)

            delta = time() - timestamp
            if delta < PAUSE_MIN_TIME:
                sleep(PAUSE_MIN_TIME - delta)

            print(trace, end='', flush=True)
            n += 1

    except KeyboardInterrupt:
        # Delete ^C character and print ellipsis
        print("\b\b", end='', flush=True)
        print("...")
import matplotlib.pyplot as plt
import matplotlib.patches as ptc
import matplotlib.patheffects as pe
from matplotlib import colormaps

from keyboard import Keyboard
from setup import setup

ARGS = setup("display")
keyboard = Keyboard.load(ARGS["keyboard"], ARGS["layout"], ARGS["frequencies"])


def draw_keyboard(layer: int, keyboard: Keyboard):
    keyboard_padding = 1
    keyboard_bbox = [0, 0, 0, 0]

    for key in keyboard.keys:
        if not ARGS["show_modifiers"] and key.is_modifier:
            continue

        # Choice colormap for key
        if ARGS["color_by"].lower() in "frequency":
            patch_color = colormaps["Purples"]((key.get_usage(layer) / keyboard.get_max_usage()) ** 0.3)
        elif ARGS["color_by"].lower() in "row":
            patch_color = colormaps["Pastel1"](key.row - 1)
        elif ARGS["color_by"].lower() in "finger":
            patch_color = colormaps["Set3"](key.finger - 1)
        elif ARGS["color_by"].lower() in "hand":
            patch_color = colormaps["Set3"](key.finger > 5)
        else:
            patch_color = (0, 0, 0, 0)

        key_patch = ptc.FancyBboxPatch(
            (key.x, -key.y - key.h),
            key.w,
            key.h,
            boxstyle="round,rounding_size=3",
            linewidth=1,
            facecolor=patch_color,
            edgecolor="black",
        )

        # Find all patch canvas border
        x0, y0, x1, y1 = key_patch.get_bbox().extents
        keyboard_bbox[0] = min(keyboard_bbox[0], x0)
        keyboard_bbox[1] = min(keyboard_bbox[1], y0)
        keyboard_bbox[2] = max(keyboard_bbox[2], x1)
        keyboard_bbox[3] = max(keyboard_bbox[3], y1)

        axs[f"layer{layer}"].add_patch(key_patch)

        # Display key info
        if ARGS["show_layout"]:
            axs[f"layer{layer}"].text(
                key.x + key.w/2,
                -key.y - key.h/2 + 0.5,
                key.get_mapping(layer),
                color="white",
                path_effects=[pe.withStroke(linewidth=2, foreground="black")],
                va="center_baseline",
                ha="center",
                fontsize=14
            )

        if ARGS["show_key_codes"]:
            axs[f"layer{layer}"].text(
                key.x + key.w/2,
                -key.y - key.h/2 + 0.5,
                key.key,
                color="white",
                path_effects=[pe.withStroke(linewidth=2, foreground="black")],
                va="top",
                ha="center",
                fontsize=7
            )

        if ARGS["show_rows"] or ARGS["show_fingers"]:
            row_or_finger = ""
            if ARGS["show_rows"]:
                row_or_finger += f"r{key.row}"

            if ARGS["show_fingers"]:
                row_or_finger += f"f{key.finger}"

            axs[f"layer{layer}"].text(
                key.x + 1.5,
                -key.y - 1.5,
                row_or_finger,
                color="white",
                path_effects=[pe.withStroke(linewidth=2, foreground="black")],
                va="top",
                ha="left",
                fontsize=6
            )

        if key.is_home and ARGS["show_home_keys"]:
            axs[f"layer{layer}"].text(
                key.x + key.w - 1.5,
                -key.y - 0.5,
                "•",
                color="white",
                path_effects=[pe.withStroke(linewidth=2, foreground="black")],
                va="top",
                ha="right",
                fontsize=6
            )

        if ARGS["show_frequencies"] and not key.is_modifier:
            axs[f"layer{layer}"].text(
                key.x + key.w/2,
                -key.y - key.h + 0.5,
                f"{key.get_frequency(layer):.2%}",
                color="white",
                path_effects=[pe.withStroke(linewidth=2, foreground="black")],
                va="bottom",
                ha="center",
                fontsize=6
            )

    def format_coord(x, y):
        selected_key = None
        for key in keyboard.keys:
            if (key.x <= x <= key.x + key.w) and (key.y <= -y <= key.y + key.h):
                selected_key = key
                break

        if not selected_key:
            return ""

        return (
            f"{key.key} \"{key.get_mapping(layer)}\", finger {key.finger}, row {key.row}\n"
            f"Frequency: {key.get_frequency(layer):.2%} on mapping, total: {key.get_total_frequency():.2%}"
        )

    axs[f"layer{layer}"].format_coord = format_coord
    axs[f"layer{layer}"].set_xlim(keyboard_bbox[0] - keyboard_padding, keyboard_bbox[2] + keyboard_padding)
    axs[f"layer{layer}"].set_ylim(keyboard_bbox[1] - keyboard_padding, keyboard_bbox[3] + keyboard_padding)

    axs[f"layer{layer}"].axis("off")
    axs[f"layer{layer}"].set_aspect("equal")


# Show stats data
keyboard.print_keyboard_usage()

# Generate plot
fig, axs = plt.subplot_mosaic(
    [["layer1"],
     ["layer2"]],
    figsize=(8, 6)
)

fig.canvas.manager.set_window_title("Keyboard")

draw_keyboard(1, keyboard)
draw_keyboard(2, keyboard)

plt.tight_layout()
plt.show()
import argparse
import tomllib


def add_argument(argument: str, parser: argparse.ArgumentParser, ARGS: dict):
    match argument:
        case "help":
            parser.add_argument(
                "-help",
                action="help",
                default=argparse.SUPPRESS,
                help="Show all script startup parameters and exit"
            )

        # Global
        case "frequencies":
            parser.add_argument(
                "-frequencies",
                help=(
                    "File which contain information about key usage frequency",
                ),
                default=ARGS["frequencies"],
                type=str,
                dest="frequencies",
            )

        case "keyboard":
            parser.add_argument(
                "-keyboard",
                help=(
                    "File which contain information about"
                    " keyboard keys placement",
                ),
                default=ARGS["keyboard"],
                type=str,
                dest="keyboard",
            )

        case "layout":
            parser.add_argument(
                "-layout",
                help=(
                    "File which contain information about keyboard"
                    " language layout of keys",
                ),
                default=ARGS["layout"],
                type=str,
                dest="layout",
            )

        # Display
        case "show_modifiers":
            parser.add_argument(
                "-m",
                help="Display modifier keys",
                action="store_const",
                const=not ARGS["show_modifiers"],
                default=ARGS["show_modifiers"],
                dest="show_modifiers",
            )

        case "show_layout":
            parser.add_argument(
                "-l",
                help="Draw layout mappings on keys at the center",
                action="store_const",
                const=not ARGS["show_layout"],
                default=ARGS["show_layout"],
                dest="show_layout",
            )

        case "show_key_codes":
            parser.add_argument(
                "-k",
                help="Draw key codes mappings on keys at the top",
                action="store_const",
                const=not ARGS["show_key_codes"],
                default=ARGS["show_key_codes"],
                dest="show_key_codes",
            )
        case "show_rows":
            parser.add_argument(
                "-r",
                help=(
                    "Draw number of row mapping for"
                    " the keys at the top right position",
                ),
                action="store_const",
                const=not ARGS["show_rows"],
                default=ARGS["show_rows"],
                dest="show_rows",
            )

        case "show_fingers":
            parser.add_argument(
                "-f",
                help="Draw finger mapping on keys at the top left position",
                action="store_const",
                const=not ARGS["show_fingers"],
                default=ARGS["show_fingers"],
                dest="show_fingers",
            )

        case "show_frequencies":
            parser.add_argument(
                "-p",
                help="Draw layout key usage frequencies",
                action="store_const",
                const=not ARGS["show_frequencies"],
                default=ARGS["show_frequencies"],
                dest="show_frequencies",
            )

        case "show_home_keys":
            parser.add_argument(
                "-h",
                help="Display dots on top right corner of home keys",
                action="store_const",
                const=not ARGS["show_home_keys"],
                default=ARGS["show_home_keys"],
                dest="show_home_keys",
            )

        case "color_by":
            parser.add_argument(
                "-c",
                help=(
                    "Mark key background according to data of frequency,"
                    "row, hand, finger or none"
                ),
                type=str,
                default=ARGS["color_by"],
                dest="color_by",
            )

        case "files":
            parser.add_argument(
                "files",
                help="List of files to be processed",
                default=ARGS["files"],
                type=str,
                nargs='+'
            )


def setup(script_name):
    settings = tomllib.load(open("settings.toml", "rb"))
    ARGS = settings[script_name]

    options = {}
    if "options" in ARGS:
        options = ARGS.pop("options")
        ARGS |= options

    # Parse arguments
    parser = argparse.ArgumentParser(add_help=False)
    add_argument("help", parser, ARGS)

    for argument in ARGS:
        add_argument(argument, parser, ARGS)

    parsed_args = dict(parser.parse_args()._get_kwargs())
    for arg in parsed_args:
        ARGS[arg] = parsed_args[arg]

    # print(ARGS)
    return ARGS
from setup import setup

ARGS = setup("frequency-checker")

# Gather all text from source files
corpus_text = ""
for file_path in ARGS["files"]:
    with open(file_path, encoding="utf-8", errors="ignore") as file:
        corpus_text += file.read()

# Compute keys frequency
frequencies = {}

keys = ARGS["allowed_glyphs"] if ARGS["allowed_glyphs"] else set(corpus_text)
for key in keys:
    frequencies[key] = corpus_text.count(key)

# Output result
frequencies = dict(sorted(frequencies.items(), key=lambda v: -v[1]))
print("info: \"Generated freqiencies\"")
for key in frequencies:
    print(f"  \"{key}\": {frequencies[key]}")
from __future__ import annotations
from typing import Literal

from yaml import safe_load


class Key():
    def __init__(self, keyboard: Keyboard, physical_key: dict, logical_key: dict):
        # Physical keyboard
        self.keyboard = keyboard
        self.key = physical_key["key"]
        self.x = physical_key["x"]
        self.y = physical_key["y"]
        self.w = physical_key["w"]
        self.h = physical_key["h"]
        self.row = physical_key["row"]
        self.finger = physical_key.get("finger", 0)

        # Logical keyboard
        self.keyboard = keyboard
        self.key = logical_key["key"]
        self.mappings = logical_key["mappings"]
        self.is_modifier = logical_key.get("is_modifier", False)
        self.is_home = logical_key.get("is_home", False)

    def get_mapping(self, layer: int):
        if layer > 0:
            return self.mappings.get(layer, self.mappings.get(layer - 1))
        raise ValueError(f"Layout mapping not found for {layer} layer")

    def get_frequency(self, layer: int):
        return self.keyboard.get_frequency(self.get_mapping(layer))

    def get_total_frequency(self):
        return sum([self.get_frequency(mapping) for mapping in self.mappings])

    def get_usage(self, layer):
        return self.keyboard.get_usage(self.get_mapping(layer))


class Keyboard():
    def __init__(self, physical_layout: dict, logical_layout: dict, keys_frequencies: dict):
        self.frequencies = keys_frequencies["frequencies"]
        self.total = sum(keys_frequencies["frequencies"].values())

        self.keyboard: dict[str, Key] = {}
        for physical_key in physical_layout["keyboard"]:
            for logical_key in logical_layout["layout"]:
                if physical_key["key"] == logical_key["key"]:
                    self.keyboard[physical_key["key"]] = Key(self, physical_key, logical_key)
                    break

        # Ehsure that layout mapped properly
        self.check_unique_keys()

    @classmethod
    def load(self, physical_layout: str, logical_layout: str, keys_frequencies: str):
        physical_layout: dict = safe_load(open(physical_layout, encoding="utf-8").read())
        logical_layout: dict = safe_load(open(logical_layout, encoding="utf-8").read())
        keys_frequencies: dict = safe_load(open(keys_frequencies, encoding="utf-8").read())

        return Keyboard(physical_layout, logical_layout, keys_frequencies)

    @property
    def keys(self) -> list[Key]:
        return self.keyboard.values()

    def check_unique_keys(self):
        dublicates_found = False
        mappings = set()
        for key in self.keys:
            if key.is_modifier:
                continue

            for mapping in key.mappings.values():
                if mapping not in mappings:
                    mappings.add(mapping)
                else:
                    dublicates_found = True
                    print(f"Warning: mapping \"{mapping}\" repeats layout more than once")

        if dublicates_found:
            print()

    def print_keyboard_usage(self):
        format_map = {"fingers": "Usage of fingers", "rows": "Usage of rows", "total": 0}
        hands_frequency = """\
        \r{fingers:^32}{rows:^19}
        \r
        \r ╭╴{l1:<6.2%}              {r10:>6.2%}╶╮      {o1}
        \r │ ╭╴{l2:<6.2%}          {r9:>6.2%}╶╮ │      {o2}
        \r 1 2 3 4                7 8 9 10     {o3}
        \r     │ ╰╴{l4:<6.2%}  {r7:>6.2%}╶╯ │          {o4}
        \r     ╰╴{l3:<6.2%}      {r8:>6.2%}╶╯          {o5}
        \r
        \r Left - {l:<6.2%}    {r:>6.2%} - Right     ∑ {total:.1%}
        \r"""

        def calculate_hand_uage(hand: Literal["left", "right"]):
            hand_frequency = 0
            fingers = ["pinky", "ring", "middle", "index", "thumb"]

            finger_direction = 1 if hand == "left" else -1
            finger_offset = 1 if hand == "left" else 6

            for finger_index, _ in enumerate(fingers[::finger_direction], finger_offset):
                finger_frequency = sum([key.get_total_frequency() for key in self.keyboard.values() if key.finger == finger_index])
                hand_frequency += finger_frequency

                format_map[f"{"l" if hand == "left" else "r"}{finger_index}"] = finger_frequency
            format_map["l" if hand == "left" else "r"] = hand_frequency

        calculate_hand_uage("left")
        calculate_hand_uage("right")

        def calculate_row_usage(row):
            row_usage = sum([
                key.get_total_frequency() for key in self.keyboard.values() if key.row == row
            ])

            format_map["total"] += row_usage
            format_map[f"o{row}"] = f"{row} {row_usage:.2%}" if row_usage != 0 else ""

        # Can display only first 6 rows
        for row in range(1, 6):
            calculate_row_usage(row)

        print(hands_frequency.format_map(format_map))

    def get_frequency(self, mapping: str):
        return self.frequencies.get(mapping, 0) / self.total

    def get_max_frequency(self):
        return max(self.frequencies.values) / self.total

    def get_usage(self, mapping: str):
        return self.frequencies.get(mapping, 0)

    def get_max_usage(self):
        return max(self.frequencies.values())
timestamp = 1750089157.451145

time_format = "%"

time = 23903456291.056763
time_bonus = 419.0
time_max = 536112000000

items = {'watch': {'name': 'Часы', 'base_cost': 25, 'multipler': 1.07, 'level': 135, 'bonus': 0.1}, 'shelf': {'name': 'Тумбочка', 'base_cost': 150, 'multipler': 1.07, 'level': 85, 'bonus': 0.5}, 'teapot': {'name': 'Чайник', 'base_cost': 500, 'multipler': 1.09, 'level': 1, 'bonus': 3}}

expedition_timeout_max = 15
expedition_timeout = -0.09999999999996345
expedition = 12
from time import time

from textual.app import App, ComposeResult
from textual.containers import Center, Horizontal, ScrollableContainer, Container, Grid
from textual.reactive import reactive
from textual.screen import ModalScreen
from textual.widgets import Static, Label, Button, ProgressBar, Tabs, ContentSwitcher, Switch, RadioSet, RadioButton

from events import *
FPS = 10
VERSION = "0.0.1"

def value_format(time):
    if app.time_format == "%":
        return f"{time / app.time_max * 100:.12f}%"
    if app.time_format == "с":
        return f"{round(time)}с"

class Item(Static):
    item_id = "ID"
    name = "NAME"
    base_value = 25
    multiplier = 1.07
    level = reactive(0)

    def __init__(self, item) -> None:
        super().__init__()

        self.item_id = item
        self.name = app.items[item]["name"]
        self.base_value = app.items[item]["base_cost"]
        self.multiplier = app.items[item]["multipler"]
        self.level = app.items[item]["level"]
        self.base_bonus = app.items[item]["bonus"]

        app.game_log += f"\nCreated item: {self.name}"
    
    def on_mount(self):
        self.set_interval(1 / FPS, self.update)

    def update(self):
        cost = self.base_value * self.multiplier ** self.level
        if app.time >= cost:
            self.query_one(f"#item-{self.item_id}-buy").disabled = False
        else:
            self.query_one(f"#item-{self.item_id}-buy").disabled = True

    def on_button_pressed(self, event: Button.Pressed):
        cost = self.base_value * self.multiplier ** self.level

        if app.time >= cost:
            app.time -= cost

            self.level += 1
            app.items[self.item_id]["level"] += 1
            app.time_bonus += self.base_bonus

    def watch_level(self):
        cost = self.base_value * self.multiplier ** self.level
        try:
            self.query_one("#item-info").update(
                f"{self.name}: {self.level}\n"
                f"Бонус: {value_format(self.level*self.base_bonus)}\n"
                f"Цена: {value_format(cost)}",
            )
        except: 
            pass
        
    def compose(self) -> ComposeResult:
        yield Static(
            f"{self.name}: {self.level}\n"
            f"Бонус: {value_format(self.level*self.base_bonus)}\n"
            f"Цена: {value_format(self.base_value * self.multiplier ** self.level)}",
            id="item-info"
        )
        yield Button("Улучшить", id=f"item-{self.item_id}-buy")

class Progress(Static):
    def compose(self):
        yield ScrollableContainer(
            *[Item(item) for item in app.items]
            # Item("Часы", "0"),
        )

class OfflineProgress(ModalScreen):
    """Screen with a dialog about offline progress"""
    afk_time = 0
    afk_bonus = 0

    def __init__(self):
        super().__init__()

        self.afk_time = time() - app.timestamp
        self.afk_bonus = sum([
            app.items[item]["level"] * app.items[item]["bonus"] * self.afk_time
            for item in self.app.items
        ])

        app.time += self.afk_bonus
        # self.app.time += 
        
    def compose(self) -> ComposeResult:
        yield Container(
            Static(f"За время вашего отсутствия было получено:\n{value_format(self.afk_bonus)} загрузки", id="question"),
            Center(Button("Ок", variant="success", id="enter")),
            id="dialog"
        )

    def on_button_pressed(self, event: Button.Pressed) -> None:
        self.app.offline_progress = False
        self.app.pop_screen()

class Expedition(Static):
    expedition = 0
    expedition_timeout_max = 0
    expedition_timeout = 0

    def __init__(self, id):
        super().__init__(id=id)
        self.expedition = app.expedition
        self.expedition_timeout_max = app.expedition_timeout_max
        self.expedition_timeout = app.expedition_timeout

    def on_mount(self):
        self.set_interval(1 / FPS, self.update)

        app.game_log += str(self.expedition)
        self.mount(Center(ProgressBar(id="expedition_timeout", total=self.expedition_timeout_max), id="timeout"), before=0)

        if self.expedition_timeout <= 0:
            self.query_one("#expedition_next_button").disabled = False
        else:
            self.query_one("#expedition_next_button").disabled = True

            # if self.expedition != 0:

            self.query_one("#expedition_timeout").advance(
                self.expedition_timeout_max - self.expedition_timeout
            )
        # if EVENTS[self.expedition][0] == "timeout":
            
        # update buttons / create / delete
        if EVENTS[self.expedition][0] == "fork":
            self.query_one("#NEXT").remove()
            self.mount(Horizontal(
                *[Button(fork) for fork in EVENTS[self.expedition][-1]],
                id="choise_buttons"
            ))

    def update(self):
        if self.expedition_timeout <= 0: return
        self.expedition_timeout -= 1 / FPS
        app.expedition_timeout = self.expedition_timeout
        app.expedition_timeout_max = self.expedition_timeout_max
        self.query_one("#expedition_timeout").advance(1 / FPS)
        
        if self.expedition_timeout <= 0:
            self.query_one(Button).disabled = False

    def on_button_pressed(self, event: Button.Pressed) -> None:
        # end event
        # if EVENTS[self.expedition][0] == "timeout" and self.expedition != 0:
        #     self.query_one("#timeout").remove()

        if EVENTS[self.expedition][0] == "fork":
            self.query_one("#choise_buttons").remove()
            # self.mount(Center(
            #     Button("Дальше", id="expedition_next_button"),
            #     id="NEXT"
            # ))

        # add loading bar and end event
        if EVENTS[self.expedition][0] == "loading":
            self.expedition_timeout = 15
            self.expedition_timeout_max = self.expedition_timeout

            # self.mount(Center(ProgressBar(total=self.expedition_timeout, id="expedition_timeout"), id="timeout"), before=0)
            
            self.query_one("#expedition_next_button").label = "Начать вылазку"
            self.query_one("#expedition_next_button").disabled = True

        # change event on next one
        if EVENTS[self.expedition][0] == "fork":
            app.game_log += f"\nSelected: {event.button.label=}, {EVENTS[self.expedition][-1]=}"
            self.expedition = EVENTS[self.expedition][-1][event.button.label._text[0]]
        else:
            self.expedition = EVENTS[self.expedition][-1]

        app.expedition = self.expedition
        app.expedition_timeout = self.expedition_timeout
        app.expedition_timeout_max = self.expedition_timeout_max

        # update texts
        self.query_one("#expedition_log").update(EVENTS[self.expedition][1])
        if EVENTS[self.expedition][0] == "loading":
            self.query_one("#expedition_next_button").label = "Закончить"
        else:
            self.query_one("#expedition_next_button").label = "Продолжить"

        # execute scripts
        if EVENTS[self.expedition][0] == "script":
            eval(EVENTS[self.expedition][2])

        # update buttons / create / delete
        if EVENTS[self.expedition][0] == "fork":
            self.query_one("#NEXT").remove()
            self.mount(Horizontal(
                *[Button(fork) for fork in EVENTS[self.expedition][-1]],
                id="choise_buttons"
            )) 
    
    def compose(self):
        with ScrollableContainer():
            yield Static(EVENTS[self.expedition][1], id="expedition_log")

            with Center(id="NEXT"):
                yield Button("Начать вылазку", id="expedition_next_button")

class Settings(Static):
    def on_button_pressed(self, event: Button.Pressed) -> None:
        app.action_quit()

    def on_radio_set_changed(self, event: RadioSet.Changed) -> None:
        app.time_format = event.pressed.label._text[0][-2]

    def compose(self):
        with ScrollableContainer():
            with Center():
                yield Static(f"17k v{VERSION}", id="info")
            
            with Center():
                yield Label("Формат отображения загрузки")
                with RadioSet(id="focus_me"):
                        yield RadioButton("Проценты (%)", value=True)
                        yield RadioButton("Секунды (с)")
                        # yield RadioButton("Минуты (м)")
                        # yield RadioButton("Часы (ч)")
                        # yield RadioButton("Дни (д)")
                        # yield RadioButton("Недели (н)")
                        # yield RadioButton("Месяца (М)")
                        # yield RadioButton("Сезоны (С)")
                        # yield RadioButton("Годы (г)")
                        # yield RadioButton("Века (в)")
                        # yield RadioButton("Тысячелетия (т)")

            with Center():
                yield Static("Выход: ctrl + c", id="info")
            
            yield ScrollableContainer(Static(app.game_log, id="log_text"), id="log")

class Game(App):
    timestamp = time()

    time_format = "%"

    time = 17_000 * 365 * 24 * 60 * 60 * 0
    time_bonus = 0
    time_max = 17_000 * 365 * 24 * 60 * 60 # 17_000 * 365 * 24 * 60 * 60

    expedition_timeout_max = 0
    expedition_timeout = 0
    expedition = 0

    game_log = "[begin debug]"
    items = {
        # id name base_cost multipler levels initial_bonus
        "watch": {
            "name": "Часы",
            "base_cost": 25,
            "multipler": 1.07,
            "level": 1,
            "bonus": 0.1
        },
        "shelf": {
            "name": "Тумбочка",
            "base_cost": 150,
            "multipler": 1.07,
            "level": 1,
            "bonus": 0.5
        },
        # "shelf": ("Тумбочка", 150, 1.07, 1, 0.5),
        # ["teapot", "Чайник", 500, 1.10, 1, 3],
        # ["cheese", "Cыр", 500_000, 1.15, 1, 15_000]
    }
    
    offline_progress = False

    tabs = {
        "Вылазки": "expedition",
        "Предметы": "loading",
        "Статистика": "statistics",
        "Достижения": "achievements",
        "Настройки": "settings",
    }
    
    active_tab = "expedition"

    CSS_PATH = "styles.tcss"
    BINDINGS = [
        ("ctrl+c", "quit", "Выход"),
    ]

    def add_item(self, item):
        self.items |= item
        app.query_one(Progress).query_one(ScrollableContainer).mount(
            Item(tuple(item.keys())[0])
        )

    def __init__(self):
        super().__init__()

        try:
            import _save
            self.offline_progress = True
            self.timestamp = _save.timestamp
            self.time_format = _save.time_format
            
            self.time = _save.time
            self.time_bonus = _save.time_bonus
            self.time_max = _save.time_max

            self.items = _save.items

            self.expedition = _save.expedition
            self.expedition_timeout_max = _save.expedition_timeout_max
            self.expedition_timeout = _save.expedition_timeout - (time() - _save.timestamp)
        except ImportError: 
            pass

    def action_quit(self):
        self.timestamp = time()
        with open('save.py', 'w') as save:
            save.write(f"timestamp = {self.timestamp}" + "\n\n")
            save.write(f"time_format = \"{self.time_format}\"" + "\n\n")
            
            save.write(f"time = {self.time}" + "\n")
            save.write(f"time_bonus = {self.time_bonus}" + "\n")
            save.write(f"time_max = {self.time_max}" + "\n\n")
            
            save.write(f"items = {self.items}" + "\n\n")

            save.write(f"expedition_timeout_max = {self.expedition_timeout_max}" + "\n")
            save.write(f"expedition_timeout = {self.expedition_timeout}" + "\n")
            save.write(f"expedition = {self.expedition}" + "\n")

        return super().action_quit()

    def on_mount(self) :
        self.time_bonus = sum([self.items[item]["level"]*self.items[item]["bonus"] for item in self.items])
        
        self.set_interval(1 / FPS, self.update)
        self.query_one("#main_loading").advance(self.time)

    def update(self) -> None:
        if self.offline_progress: return

        self.time += (1 + self.time_bonus) / FPS
        self.query_one("#main_percentage").update(value_format(self.time)) # 100 * self.time / self.time_max:.10f
        self.query_one("#main_loading").advance((1 + self.time_bonus) / FPS)
    
    def on_tabs_tab_activated(self, event: Tabs.TabActivated) -> None:
        if self.offline_progress:
            self.push_screen(OfflineProgress())
            return
        
        self.active_tab = self.tabs[event.tab.label._text[0]]
        self.query_one(ContentSwitcher).current = self.active_tab
        
        self.game_log += f"\nSelected: {self.tabs[event.tab.label._text[0]]}"
        self.query_one("#log_text").update(self.game_log)

    def compose(self) -> ComposeResult:
        with Center():
            yield ProgressBar(total=self.time_max, show_eta=False, show_percentage=False, id="main_loading")

        with Center():
            yield Label(f"{value_format(self.time)}", id="main_percentage")

        with ContentSwitcher(initial=self.active_tab):
            yield Progress(id="loading")
            yield Expedition(id="expedition")
            yield Label(id="statistics")
            yield Label(id="achievements")
            yield Settings(id="settings")

        yield Tabs(*tuple(self.tabs.keys()))

app = Game()
app.run()
EVENTS = {
    0: ("timeout", "Начало", 1),
    1: ("fork", "Вы вышли к развилке", {"Налево": 2, "Направо": 4}),
    2: ("text", "Налево?", 3),
    3: ("loading", "Ну и ладно, пауза", 5),
    4: ("text", "Направо?", 3),

    5: ("timeout", "Теперь я сижу дома и отдыхаю", 6),
    6: ("text", "Ладно, может мне куда выйти?", 7),
    7: ("script", "О, чайник!\nВы нашли [yellow]чайник[/yellow]", 'app.add_item({"teapot": {"name": "Чайник", "base_cost": 500, "multipler": 1.09, "level": 1, "bonus": 3}})', 8),
    8: ("loading", "Не, не хочу никуда идти, лучше чая попью", 9),

    9: ("timeout", "Перерыв, надо отдохнуть", 10),
    10: ("text", "Что-то сегодня совсем нет сил никуда идти", 11),
    11: ("loading", "Лучше останусь в каюте", 12),

    12: ("timeout", "Гротеск", 13),
    13: ("text", "Включилась система сигнализации. На [cyan]Гротеске[/cyan] была ночь. Конечно, время суток в космосе - дело относительное, но в левом крыле была ночь. Лео продолжал ворочаться на своей полочке, как вдруг зазвучал этот пронзительный вой.", 14),
    14: ("text", "Отходя ото сна Лео сел на койку.\n- И зачем делать отдельные каюты, если они такие маленькие?\n- Как будто 80 процентов корабля это одни стены.", 15),
    15: ("text", "Пока Лео додумывал свои размышления, к нему без стука вошли. Это был Ной. И какого чёрта он тут делает? - пронеслось у Лео в голове. Ной, всё ещё молчавший, достал ноутбук и поставил на пустой прикроватный столик. ", 16),
    16: ("text", "- Лео…\nНачал было он, как Лео сразу же возразил\n- Нет, Ной. Это чушь какая-то.\nЛицо Ноя начало краснеть, старик явно был не в настроении, звук сирены продолжал сжимать голову. ", 17),
    17: ("text", "- Нет. Это не чушь. - На ноутбуке Ноя было открыто окно загрузки. Это была загрузка отправки сообщения о варпе.\n- Мы вышли слишком близко к чёрной дыре.\n- Ну не на столько же близко, чтобы через месяц загрузка только начала прогружаться, Ной?\n- На столько. ", 18),
    18: ("text", """
- Ну и? Сколько там осталось?
- 17 тысяч лет.
- Ха! Да ладно. 17… тысяч - до Лео всё не доходило - 17, стоп, лет?
- Да, Лео, лет. 
- Не-не-не… ты… ты просто отмени загрузку, попробуй с другого…
- Не работает. Нам надо что-то делать с этим. 
- Ох, нам? Может ты сначала скажешь, чтобы сирену отключили?
Внезапно сирена сама отключилась. Ноя тоже это смутило. 
- Нет, сирена вообще не к этому, мы просто слишком много груза потеряли, вот она и включилась. 
- Ладно, но.. но я то что с этим сделаю? Ты предлагаешь мне пошаманить над этой загрузкой, чтобы она сменилась с 17 тысяч лет до 2 минут? 
- Я-я не знаю, Лео. Во всяком случае это - он указал но ноутбук - теперь это твоя ответственность. А мне, знаешь, мне пора идти. Да.
- Нет, Ной, ты не можешь…
- Молчать! Кто на этом корабле главный? М? Чтобы завтра загрузка сдвинулась! Всё, отбой.
Ной быстро выбежал из каюты.""", 19),
    19: ("loading", "Теперь Лео остался наедине с новой проблемой. Он бросил взгляд на загрузку. Вот уж действительно, 17 тысяч лет ожидания были перед ним. \n- Чтож, ну… попробуем сначала немного подождать…", 20),
    20: ("timeout", "Лео сидит и пялится на загрузку.", 5),

    # : ("", ),

    # 1: ("text", "Справа оказался мешок с деньгами\nПолучен мешок с деньгами", 2),
    # 2: ("loading", "Финал задания", 3),
    # 3: ("timeout", "Самое время отдохнуть", 4),
    
    # 4: ("text", "next event", 5),
    # 5: ("text", "Ивент 2 в самом разгаре", 6),
    # 6: ("loading", "Всё, 2 ивент закончился", 7),
    # 7: ("timeout", "жду чанки дальше", 0),
        
    # 8: ("fork", "Вы вышли на улицу", {"Пойти налево": 2, "Пойти направо": 0}),
    # 9: ("text", "Слева был тупик, вы совсем зыбли об этом", 3),
    # 10: ("inline", "Справа оказался мешок с деньгами, вы вспоминаете, что у вас {} времени", ("globals()['app.time']"),  4),
    # 11: ("script", "Вам дали ложку", "app.query_one(Progress).query_one(ScrollableContainer).mount(Item(['Teapot', 'Чайник', 500, 1.10, 1, 3]))", -1),
}

event_step = 3
event_current = 0

'''
+ Загрузка
+ Таймаут
+ Текст
+ Развилки c условиями
+ Скрипты
Инлайн значения?


"teapot": {"name": "Чайник", "base_cost": 500, "multipler": 1.09, "level": 1, "bonus": 3}

с секунды
м минуты
ч часы
д дни
н недели
М месяца
С сезоны?
г годы
в века
т тысячелетия
'''from textual.app import App, ComposeResult
from textual.containers import Grid
from textual.screen import ModalScreen
from textual.widgets import Button, Footer, Header, Label

TEXT = """I must not fear.
Fear is the mind-killer.
Fear is the little-death that brings total obliteration.
I will face my fear.
I will permit it to pass over me and through me.
And when it has gone past, I will turn the inner eye to see its path.
Where the fear has gone there will be nothing. Only I will remain."""


class QuitScreen(ModalScreen):
    """Screen with a dialog to quit."""

    def compose(self) -> ComposeResult:
        yield Grid(
            Label("Are you sure you want to quit?", id="question"),
            Button("Quit", variant="error", id="quit"),
            Button("Cancel", variant="primary", id="cancel"),
            id="dialog",
        )

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "quit":
            self.app.exit()
        else:
            self.app.pop_screen()


class ModalApp(App):
    """An app with a modal dialog."""

    CSS_PATH = "styles.css"
    BINDINGS = [("q", "request_quit", "Quit")]

    def compose(self) -> ComposeResult:
        yield Header()
        yield Label(TEXT * 8)
        yield Footer()

    def action_request_quit(self) -> None:
        """Action to display the quit dialog."""
        self.push_screen(QuitScreen())


if __name__ == "__main__":
    app = ModalApp()
    app.run()timestamp = 1693057445.146972

time_format = "%"

time = 7169333.304401871
time_bonus = 419.0
time_max = 536112000000

items = {'watch': {'name': 'Часы', 'base_cost': 25, 'multipler': 1.07, 'level': 135, 'bonus': 0.1}, 'shelf': {'name': 'Тумбочка', 'base_cost': 150, 'multipler': 1.07, 'level': 85, 'bonus': 0.5}, 'teapot': {'name': 'Чайник', 'base_cost': 500, 'multipler': 1.09, 'level': 121, 'bonus': 3}}

expedition_timeout_max = 15
expedition_timeout = -400834.9000869751
expedition = 20
from random import random, randint, choice

white_pixel = (
    b"\x89PNG\r\n\x1a\n\x00"
    b"\x00\x00\rIHDR\x00\x00"
    b"\x00\x01\x00\x00\x00\x01"
    b"\x08\x02\x00\x00\x00\x90wS"
    b"\xde\x00\x00\x00\x01sRGB\x00"
    b"\xae\xce\x1c\xe9\x00\x00\x00"
    b"\x0cIDAT\x08\x99c\xf8\xff\xff"
    b"?\x00\x05\xfe\x02\xfeX\xf2k\x0e"
    b"\x00\x00\x00\x00IEND\xaeB`\x82\n"
)

dailys = 180*2
imgs = [0, 0, 1, 1, 1, 1, 3, 4]
themes = [1, 1, 1, 1, 1, 2]
themes_variation = [1, 60]

dream_chance = .1
special_chance = .05

# daily
img = 0
dream = 0
special = 0
for i in range(dailys):
    note = open(f"notes/note-{i}.md", "w+")
    
    note.write(f"Hi, this is {i} note\n\n")
    # if i % 7 != 0:
    #     note.write(f"[[notes/note-{i-1}]]\n")
    
    # attachments 
    for _ in range(0, choice(imgs)):
        img += 1
        open(f"img/image-{img}.png", "wb").write(white_pixel)
        note.write(f"![[img/image-{img}.png]]\n")
    
    # themes
    for _ in range(choice(themes)):
        note.write(f"Talked about theme: [[theme-{randint(*themes_variation)}]]\n")
        
    # dream
    if random() <= dream_chance:
        dream += 1
        open(f"notes/dream-{dream}.md", "w+")
        note.write(f"also was dream: [[dream-{dream}.md]]")
    
    # special
    if random() <= special_chance:
        special += 1
        open(f"notes/special-{special}.md", "w+")
        note.write(f"also was special: [[special-{special}.md]]")
    
    note.close()

totals = 4
imgs = [10, 20]
themes = [18, 30]

totals
for i in range(totals):
    total = open(f"notes/total-{i}.md", "w+")
    total.write(f"Hi, this is symmary by this notes:\n\n")
    
    # attachments 
    for _ in range(0, randint(*imgs)):
        total.write(f"![[img/image-{randint(0, img)}.png]]\n")
    
    # themes
    for _ in range(randint(*themes)):
        t = themes_variation[1]//totals
        total.write(f"Talked about theme: [[theme-{randint(t*(i), t*(i+1))}]]\n")
    
    total.close()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime
import numpy as np

with open('counter_log.txt', 'r') as file:
    lines = file.readlines()

dates = []
for line in lines:
    date = datetime.strptime(line.strip(), '%Y-%m-%d %H:%M:%S')
    dates.append(date)

dates.sort()
counts = list(range(1, len(dates) + 1))

# Create plot
fig = plt.figure(figsize=(12.5, 5.7))
fig.canvas.manager.set_window_title("Counter")

plt.plot(
    dates, 
    counts, 
    color="tab:purple",
    linewidth=3
)

plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d.%m.%Y'))
plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator())

plt.yticks(np.linspace(1, len(dates), 10, dtype=int))

plt.margins(x=0, y=0)
plt.title('Результат накручивания счётчика')

plt.tight_layout()
plt.show()
import locale
import shutil
from datetime import datetime
from pathlib import Path
from bs4 import BeautifulSoup

# Copilot Generated with mine guidance
# TODO:
# - Parse tables
# - Parse text formatting

# Set locale for Russian language
locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')

# Define directories
pages = Path('./pages')
markdown_dir = Path('./markdown')
images_dir = Path('./images')

# Clear the markdown directory before starting
if markdown_dir.exists():
    shutil.rmtree(markdown_dir)
markdown_dir.mkdir(exist_ok=True)

# Global counters
images = 0
dreams = 0

# Month mapping for Russian months
months = {
    'января': 'Январь',
    'февраля': 'Февраль',
    'марта': 'Март',
    'апреля': 'Апрель',
    'мая': 'Май',
    'июня': 'Июнь',
    'июля': 'Июль',
    'августа': 'Август',
    'сентября': 'Сентябрь',
    'октября': 'Октябрь',
    'ноября': 'Ноябрь',
    'декабря': 'Декабрь'
}

def parse_html_to_markdown(filename, html_content, attachments_dir):
    """
    Parse HTML content and convert it to Markdown format.
    Handles images, text, and special tags.
    """
    global images
    soup = BeautifulSoup(html_content, 'html.parser')

    # Extract date from filename
    date_str = filename.split(' - ')[-1].replace('.html', '').replace('Z', '')
    created_date = datetime.fromisoformat(date_str)
    formatted_date = created_date.strftime('%A, %d %B %Yг. %H:%M')
    year_month_tag = f"{created_date.strftime('%Y')}/{months[created_date.strftime('%B')]}"

    # Check for specific tags in the filename
    is_summary = "Итоги" in filename
    is_8_800 = "8-800" in filename

    # Extract text and images from the HTML body
    body = soup.body
    text_parts = []
    if body:
        for element in body.find_all(['p', 'br', 'img']):
            if element.name == 'p':
                text = element.get_text()
                if element.get('data-tag') == 'music-to-listen-to':
                    text = "♫ " + text
                if text_parts and not text_parts[-1].endswith("\n"):
                    text_parts.append(" ")
                text_parts.append(text + "\n")
            elif element.name == 'br':
                text_parts.append("\n")
            elif element.name == 'img':
                if text_parts and not text_parts[-1].endswith("\n"):
                    text_parts.append("\n")
                # Sort images by numerical order in their filenames
                sorted_images = sorted(images_dir.glob('*'), key=lambda img: int(img.name.split(' ')[0]))
                image_path = sorted_images[images]
                new_image_name = f"IMG-{images}{image_path.suffix}"
                target_image_path = attachments_dir / new_image_name
                shutil.copy(image_path, target_image_path)
                text_parts.append(f"![[{new_image_name}]]\n")
                images += 1

    # Create YAML header for Markdown
    yaml_header = f"---\ntags:\n  - {year_month_tag}"
    if is_summary:
        yaml_header += "\n  - Итоги"
    if is_8_800:
        yaml_header += "\n  - 8-800"
    yaml_header += "\n---\n"

    # Combine all parts into the final Markdown content
    markdown_content = f"{yaml_header}**{formatted_date}**\n***\n"
    markdown_content += "".join(text_parts)

    return markdown_content

# Process each HTML file in the pages directory
for html_file in sorted(
    pages.glob('*.html'),
    key=lambda f: int(f.name.split(' ')[0])
):
    # Extract year and month from the filename
    date_str = html_file.name.split(' - ')[-1].replace('.html', '').replace('Z', '')
    created_date = datetime.fromisoformat(date_str)
    year_dir = markdown_dir / created_date.strftime('%Y')
    month_name = months[created_date.strftime('%B').lower()]
    month_dir = year_dir / month_name
    month_dir.mkdir(parents=True, exist_ok=True)

    # Create attachments directory for the current file
    attachments_dir = month_dir / "Вложения"
    attachments_dir.mkdir(exist_ok=True)

    # Transform the filename
    central_part = html_file.name.split(' - ')[1].strip()
    if "Сон" in central_part or "Сны" in central_part:
        transformed_name = f"Сон ({dreams})"
        dreams += 1
    else:
        transformed_name = central_part.replace('[', '(').replace(']', ')').replace('.afk', 'afk')
    
    markdown_file = month_dir / f"{transformed_name}.md"

    # Convert HTML to Markdown
    with html_file.open('r', encoding='utf-8') as f:
        markdown_content = parse_html_to_markdown(html_file.name, f.read(), attachments_dir)
    
    # Write the Markdown content to a file
    with markdown_file.open('w', encoding='utf-8') as f:
        f.write(markdown_content)
    
    print(f"Created {markdown_file}")
all_words = open("dictionaries/opencorpora.dic").read().split()
all_words = set(word.lower() for word in all_words)

founded = set()
total_words = len(all_words)
skip = 0

for i, word in enumerate(all_words):
    if i < skip or word.isdigit():
        continue
    
    print(f'\r{i}/{total_words}', end='')

    if word[::-1] in all_words and word not in founded and word[::-1] not in founded:
        founded.add(word)
        # print(word, "|", word[::-1])

print()

for word in sorted(list(founded), key=lambda v: len(v)):
    print(word, word[::-1])
from itertools import permutations, islice
from sys import maxsize

from utils import *

keys = "абвгдеежзийклмнопрстуфхцчшщъыьэюя"
all_words = open("dictionaries/russian-cleared.dic").read().split()

# Комбинаций
# 33!        Без пробелов
# 33! * 2^32 С пробелами
# ---
# 8.9x10^36 Комбинаций

skip = 18000  # От 0 до 9223372036854775807

generator = permutations(keys, len(keys))
generator = islice(generator, skip, maxsize)

counter = skip
for permutation in generator:
    sentence = "".join(permutation)
    print(f"Go on permutation {counter}: {sentence}")

    sentence_inlcudings = [0] * len(sentence)
    for word in all_words:
        try:
            start = sentence.index(word.lower())
            stop = start + len(word)

            for i in range(start, stop):
                sentence_inlcudings[i] += 1

        except ValueError:
            continue

    if all([v != 0 for v in sentence_inlcudings]):
        store(sentence, sentence_inlcudings)
        print(sentence, sentence_inlcudings)
    
    counter += 1
with open("dictionaries/obsidian.dic") as file:
    lines = file.readlines()
    
    for line in lines:
        if len(set(line)) == len(line):
            print(line, end='')
from string import punctuation

# Store founded value in file
def store(*values):
    values = [str(value) for value in values]

    with open("results.txt", "a+") as file:
        file.write(f"{' '.join(values)}\n")

# Clear dictionary
def clear_dictionary(filename: str):
    name, extension = filename.split(".")

    all_words = open(filename).read().split()
    cls_words = []

    for i, word in enumerate(all_words):
        # All symbols must be unique except "е"
        word_ingrore_e = word.replace("е", "")
        if len(set(word_ingrore_e)) != len(word_ingrore_e):
            print("Skipped", word, f"({i})")
        else:
            cls_words.append(word)

    with open(f"{name}-cleared.{extension}", "w+") as dictionary:
        for word in cls_words:
            dictionary.write(f"{word}\n")

    print("Deleted", len(all_words) - len(cls_words), "words")

def is_pangramm(sentence: str, keys: list | str):
    sentence = sentence.lower()
    sentence = sentence.translate({ord(k): None for k in punctuation + " "})
    
    return set(sentence) == set(keys) and len(sentence) == len(keys)

def sort_results():
    results = open("results.txt", "r").read().split("\n")
    results = set([frozenset(sentence.split()) for sentence in results])  # Remove doubles
    results = sorted(results, key=lambda v: len(v), reverse=True)
    
    for result in results:
        print(*list(result))

def clean_opencorpora():
    results = open("opencorpora.dic", "r").read().split("\n")
    doubles = set()

    with open("opencorpora-cleared.dic", "w") as file:
        for result in results:
            result = result.split("\t")[0].lower()

            if result == "" or result.isnumeric():
                # file.write(f"{result}\n")
                continue

            if len(set(result)) != len(result):
                continue

            if result not in doubles:
                doubles.add(result)
                file.write(f"{result}\n")

def key_frequency(source_file, watch_keys):
    sausage = open(source_file, "r").read()
    keys = {}

    for key in sausage:
        if key not in watch_keys:
            continue

        if key in keys:
            keys[key] += 1
        else:
            keys[key] = 1

    print(''.join(sorted(keys, key=lambda key: keys[key], reverse=True)))

def get_last_keys(word, keys: list):
    for key in word:
        if key in keys:
            keys.remove(key)
    
    return keys
from utils import *

keys = list("абвгдеёжзийклмнопрстуфхцчшщъыьэюя")
all_words = open("dictionaries/obsidian-cleared.dic").read().split()

# Комбинаций на слой
# 0        1       2       3       4       5       6      7     8     9     10    11   12
# 429611   91037   76076   50496   26628   10000   4418   791   551   200   100   20   5
# ---
# ~1.5×10^44 Комбинаций

skip = [29,]
cmbs = []

def word_score(word, phrequency="аоиернувстлмкпяыдшюбьзйгхчжщёцфэъ"):
    score = len(word)

    for key in word:
        score += phrequency.index(key)

    if "ъ" in word:
        score += 1000

    return score

def wfilter(words: list, keys: list):
    filtered = []

    for word in words:
        if all([word.count(key) <= keys.count(key) for key in word]):
            filtered.append(word)

    filtered.sort(key=word_score, reverse=True)
    # print(*filtered, sep="\n"); exit()

    return filtered

def travel(words: list, trace: set, keys: list, depth: list):
    words = wfilter(words, keys)
    depth.append([0])

    # Optimisation by coverage
    if set("".join(words)) != set(keys):
        return

    for i, word in enumerate(words):
        depth[-1] = i

        # Skip by layers
        skip_layer = False
        for j, k in zip(depth, skip):
            if j == k:
                continue
            if j > k:
                break
            if j < k:
                skip_layer = True
                break

        if skip_layer:
            continue

        # Update trace and available keys
        folding_trace = trace.copy()
        folding_keys = keys.copy()

        folding_trace.add(word)
        for key in word.lower():
            folding_keys.remove(key)

        # Debug info
        if len(depth) <= 2:
            print(" " * len(depth), end="")
            print(*depth, sep=" -> ", end="")
            print(f"/{len(words) - 1} {folding_trace}")

        # If all keys not covered, enter on new layer
        if len(folding_keys) != 0:
            travel(
                words[i:],
                folding_trace,
                folding_keys,
                depth[:]
            )
        else:
            if folding_trace not in cmbs:
                cmbs.append(folding_trace)

                store(' '.join(sorted(folding_trace)))
                print(f"FOUNDED: {folding_trace}")

# Test
travel(all_words, set(), keys, [])
# travel(all_words, {"любя", "съешь", "мэр", "кайф"}, list("вздохнётжгучщипцы"), [])
# travel(all_words, set(), list("жутьдюнчвшкаф"), [])
# travel(all_words, set("слёзы"), get_last_keys("слёзы", keys), [])
import urwid

from random import randint, choice

DEBUG = False

class LevelObject:
    def __init__(self, x, y, name, icon):
        self.type = "object"

        self.x = x
        self.y = y

        self.name = name
        self.icon = icon

    def __str__(self):
        return f"{self.name} x:{self.x}, y:{self.y}"

class SolidObject(LevelObject):
    def __init__(self, x, y, name, icon, hp=10):
        super().__init__(x, y, name, icon)
        self.type = "solid"
        self.hp = hp

    def __str__(self):
        return super().__str__() + f", hp:{self.hp}"

    def update(self):
        if self.hp <= 0:
            if self.name == "ore":
                player.weigth += 0.5
            
            elif self.name == "wall":
                player.weigth += 0.1

            level.objects.insert(0, LevelObject(self.x, self.y, "empty", "."))
            level.objects.remove(self)

class Level:
    def __init__(self):
        self.objects: list[LevelObject] = []

        self.vx = 0
        self.vy = 0
        self.vw = 80
        self.vh = 24

    def generate_level(self):
        # Generate some objects
        worm_x = 20
        worm_y = 12

        for step in range(10_000):
            item = choice([
                # ["wall", "#"],
                ["ore", "%", 10],
                ["water", "≈"],
                ["empty", "."],
                ["empty", "."],
                ["empty", "."],
            ])

            if self.get_object(worm_x, worm_y) == False:
                self.objects.append(
                    LevelObject(worm_x, worm_y, *item)
                    if len(item) == 2 else
                    SolidObject(worm_x, worm_y, *item)
                )

            worm_x += randint(-1, 1)
            worm_y += randint(-1, 1)

    def unhandled_input(self, key: str):
        # Update screen
        game.set_text(level.get_view())
    
    def get_view(self):
        view = [[("#", "wall") for x in range(self.vw // 2)] for y in range(self.vh)]

        for obj in self.objects:
            if (obj.x >= self.vx and obj.x < self.vx + self.vw // 2 and
                obj.y >= self.vy and obj.y < self.vy + self.vh
            ):
                view[obj.y - self.vy][obj.x - self.vx] = (obj.icon, obj.name)
        
        # Make string
        view_text = []
        for line in view:
            view_text.extend([(k[1], k[0] + ' ') for k in line])
        
        return view_text
    
    def get_object(self, x, y):
        for obj in self.objects:
            if obj.x == x and obj.y == y:
                return obj
        return False

class Player(SolidObject):
    def __init__(self, x, y):
        super().__init__(x, y, "player", "@", 100)

        self.weigth = 0

    def move(self, dx, dy):
        obj = level.get_object(self.x + dx, self.y + dy)
        
        if obj == False:  # Wall
            obj = SolidObject(self.x + dx, self.y + dy, "wall", "#", 2)
            level.objects.insert(0, obj)

        if obj and obj.name in {"empty", "water"}:
            self.x += dx
            self.y += dy

            if not (level.vx + 10 <= self.x <= level.vx + level.vw // 2 - 10) \
            or not (level.vy + 8 <= self.y <= level.vy + level.vh - 8):
                level.vx += dx
                level.vy += dy

        elif obj and obj.type == "solid":
            log.info(f"Damage obj: {obj.name} {obj.hp}")
            obj.hp -= 1
            obj.update()
    
    def update(self):
        header = [
            ("red", " ❤ "), ("white", f"{self.hp} "),
            ("yellow", " β "), ("white", f"{round(self.weigth, 2)}")
        ]
        
        head.set_text(header)
        view.set_overlay_parameters(
            align='left',
            valign='bottom',
            width=len(''.join([v[1] for v in header])) + 1,
            height=1,
        )

    def unhandled_input(self, key: str):
        actions = {
            # Straight
            "h": (-1, 0),
            "l": (+1, 0),
            "j": (0, +1),
            "k": (0, -1),
            # Diagonal
            "y": (-1, -1),
            "u": (+1, -1),
            "b": (-1, +1),
            "n": (+1, +1),
        }

        if key in actions:
            dx, dy = actions[key]
            self.move(dx, dy)

        self.update()

class Log:
    def __init__(self):
        self.content = "Hello, Moreorea!"
    
    def info(self, content):
        self.content = content + "\n" + self.content
        self.update()

    def __str__(self):
        return self.content
    
    def unhandled_input(self, key: str):
        if key not in {'t'}:
            return

        # Open or close log
        global DEBUG

        if DEBUG:
            loop.widget = view
        else:
            loop.widget = urwid.Overlay(
                dock,
                view,
                align='left',
                valign='bottom',
                width=80,
                height=5,
            )

        DEBUG = not DEBUG

    def update(self):
        logs.set_text(self.content)

def unhandled_input(key: str):
    if key in {'q', "esc"}:
        raise urwid.ExitMainLoop()

    player.unhandled_input(key)
    level.unhandled_input(key)
    log.unhandled_input(key)

# Fucking OOP
palette = [
    ("white", "white", ''),
    ("red", "dark red", ''),
    ("yellow", "yellow", ''),

    ("player", "bold, light blue", ''),
    ("empty", "black", ''),
    ("wall", "bold, black", ''),
    ("water", "dark cyan", ''),
    ("ore", "dark magenta", ''),
]

# Objects
level = Level()
level.generate_level()

player = Player(20, 12)
level.objects.append(player)

log = Log()

# Urwid widgets
logs = urwid.Text(str(log))
dock = urwid.LineBox(
    urwid.ScrollBar(urwid.Scrollable(logs)),
    title="log",
    blcorner="",
    brcorner="",
    bline="",
    lline="",
    rline="",
)

head = urwid.Text("player stats")
# rigt = urwid.LineBox(
#     head,
#     blcorner="",
#     brcorner="",
#     bline="",
#     rline="",
#     tline="",
# )

game = urwid.Text(level.get_view(), wrap="any")
view = urwid.Overlay(
    urwid.Filler(head),
    urwid.Filler(game),
    align='left',
    valign='top',
    width=5,
    height=1,
)

# Update player info
player.update()

loop = urwid.MainLoop(view, palette=palette, unhandled_input=unhandled_input)
loop.run()
import matplotlib.pyplot as plt
import numpy as np

from datetime import datetime
import calendar

# Prepare
months = [
    'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
    'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
]

# Fix labels by adding spaces and newlines
months[3] = ' ' * 4 + months[3]
months[5] = ' ' + months[5]
months[6] = '\n' + months[6]
months[8] += ' ' * 9
months[9] += ' ' * 5

fig, ax = plt.subplots(
    subplot_kw={'projection': 'polar'}
)

fig.canvas.manager.set_window_title('Часы года')

# Get time arrow
year = datetime.now().year
year_day = datetime.now().timetuple().tm_yday
year_days = 365 + calendar.isleap(year)

leap = calendar.isleap(year)

# Number of days passed in summer
summer_day = min(max(0, year_day - (31 + 28 + leap + 31 + 30 + 31)), 30 + 31 + 31)
summer_percentage = summer_day / (30 + 31 + 31)

# Number of days passed outside of summer
non_summer_day = year_day - summer_day
non_summer_percentage = non_summer_day / (365 + leap - (30 + 31 + 31))

# Summer takes 157.5 deg and non summer are 202.5 deg
year_percentage = summer_percentage * 157.5 / 360 + non_summer_percentage * 202.5 / 360

ax.plot(
    [2*np.pi * year_percentage - np.pi / 2 for _ in range(3)],
    [i for i in range(3)],
    color='tab:gray',
    linewidth=8,
    solid_capstyle='round'
)

# Pretty styled clock
ax.set_title('Часы года', pad=20)
ax.set_xticks([np.deg2rad(v) for v in [
    # Summer, each month is 52.5 deg, starts from 22.5 deg 
    *[22.5 + 52.5*i for i in range(3)],
    # Non summer, each month is 22.5 deg and starts from 180 deg
    *[180 + 22.5*i for i in range(9)]
]])

ax.set_xticklabels(months[(i + 5) % 12] for i in range(12))

ax.set_rticks([])
ax.set_rmax(2.3)

ax.grid(linestyle='--')

plt.tight_layout()
plt.show()
